<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  >
  <title>Markdown Editor with SQL & Web Components</title>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css"
  >
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css"
  >
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"
  ></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/markdown/markdown.min.js"
  ></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"
  ></script>

  <script type="importmap">
  {
    "imports": {
      "@duckdb/duckdb-wasm": "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm",
      "vega": "https://cdn.jsdelivr.net/npm/vega@6.2.0/build/vega.js",
      "vega-lite": "https://cdn.jsdelivr.net/npm/vega-lite@6.4.1/build/vega-lite.js",
      "vega-embed": "https://cdn.jsdelivr.net/npm/vega-embed@7.0.2/+esm"
    }
  }
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      height: 100vh;
      gap: 1px;
      background: #ddd;
    }

    .panel {
      background: white;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel-header {
      padding: 12px 16px;
      background: #f5f5f5;
      border-bottom: 1px solid #ddd;
      font-weight: 600;
      font-size: 14px;
      color: #333;
    }

    .editor-container {
      flex: 1;
      overflow: hidden;
    }

    .CodeMirror {
      height: 100%;
      font-size: 14px;
    }

    .preview-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .preview-content {
      max-width: 800px;
      margin: 0 auto;
    }

    .preview-content h1 {
      font-size: 2em;
      margin: 0.67em 0;
    }

    .preview-content h2 {
      font-size: 1.5em;
      margin: 0.75em 0;
    }

    .preview-content h3 {
      font-size: 1.17em;
      margin: 0.83em 0;
    }

    .preview-content p {
      margin: 1em 0;
      line-height: 1.6;
    }

    .preview-content code {
      background: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }

    .preview-content pre {
      background: #f4f4f4;
      padding: 16px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 1em 0;
    }

    .preview-content pre code {
      background: none;
      padding: 0;
    }

    .sql-result {
      margin: 16px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
    }

    .sql-result summary {
      padding: 12px;
      background: #f8f9fa;
      cursor: pointer;
      font-weight: 500;
      user-select: none;
    }

    .sql-result summary:hover {
      background: #e9ecef;
    }

    .sql-result-content {
      padding: 12px;
      max-height: 400px;
      overflow: auto;
    }

    .sql-result table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .sql-result th,
    .sql-result td {
      padding: 8px 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    .sql-result th {
      background: #f8f9fa;
      font-weight: 600;
      position: sticky;
      top: 0;
    }

    .sql-result tr:hover {
      background: #f8f9fa;
    }

    .sql-error {
      padding: 12px;
      background: #fee;
      color: #c33;
      border-left: 4px solid #c33;
      margin: 16px 0;
      border-radius: 4px;
    }

    .loading {
      padding: 12px;
      background: #fff3cd;
      color: #856404;
      border-left: 4px solid #ffc107;
      margin: 16px 0;
      border-radius: 4px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="panel">
      <div class="panel-header">Markdown Editor</div>
      <div class="editor-container">
        <textarea id="editor"># Markdown + SQL + Web Components

Write your markdown here and see it rendered in real-time!

## Product List Query

```sql name='productList'
SELECT DISTINCT product
FROM (
  SELECT 'Product A' as product, 100 as sales, 'Q1' as quarter
  UNION ALL SELECT 'Product B', 150, 'Q1'
  UNION ALL SELECT 'Product C', 120, 'Q1'
  UNION ALL SELECT 'Product A', 130, 'Q2'
  UNION ALL SELECT 'Product B', 180, 'Q2'
  UNION ALL SELECT 'Product C', 140, 'Q2'
) t
ORDER BY product
```

## Product Filter

<dropdown-component data='${productList}' name='productSelection'></dropdown-component>

## Sample SQL Query

```sql name='salesData'
WITH source_data AS (
  SELECT 'Product A' as product, 100 as sales, 'Q1' as quarter
  UNION ALL SELECT 'Product B', 150, 'Q1'
  UNION ALL SELECT 'Product C', 120, 'Q1'
  UNION ALL SELECT 'Product A', 130, 'Q2'
  UNION ALL SELECT 'Product B', 180, 'Q2'
  UNION ALL SELECT 'Product C', 140, 'Q2'
)
SELECT * FROM source_data
WHERE ${productSelection} = [] -- Show all when no selection (after replacement)
  OR product IN (SELECT unnest(${productSelection}))
```

## Using Data in Web Components

<data-table-component data='${salesData}'></data-table-component>

## Sales Chart Visualization

<vegalite-chart
  spec='{"$schema": "https://vega.github.io/schema/vega-lite/v6.json",
  "description": "Sales by Product and Quarter",
  "mark": "bar",
  "encoding": {
    "x": {"field": "product", "type": "nominal", "title": "Product"},
    "y": {"field": "sales", "type": "quantitative", "title": "Sales"},
    "color": {"field": "quarter", "type": "nominal", "title": "Quarter"}
  }}'
  data='${salesData}'>
</vegalite-chart>

## Another Query

```sql name='summary'
SELECT
  SUM(sales) as total_sales,
  AVG(sales) as avg_sales,
  COUNT(*) as num_products
FROM (
  SELECT 'Product A' as product, 100 as sales
  UNION ALL SELECT 'Product B', 150
  UNION ALL SELECT 'Product C', 120
) t
```

<data-card data='${summary}'></data-card>
</textarea>
      </div>
    </div>

    <div class="panel">
      <div class="panel-header">Preview</div>
      <div class="preview-container">
        <div
          class="preview-content"
          id="preview"
        ></div>
      </div>
    </div>
  </div>

  <script type="module">
    import vegaEmbed from 'vega-embed';

    // Dropdown Web Component (renamed from ProductFilter)
    class Dropdown extends HTMLElement {
      static get observedAttributes() { return ['data', 'name']; }

      constructor() {
        super();
        this._data = null;
        this._name = '';
        this._selectedValues = [];
      }

      attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'data') {
          const queryName = newValue.replace(/[${}]/g, '');
          this._data = dataStore[queryName];
          this.render();
        }
        if (name === 'name') {
          this._name = newValue;
        }
      }

      connectedCallback() {
        this.render();
      }

      render() {
        if (!this._data) {
          this.innerHTML = '<p style="color: #999;">Loading products...</p>';
          return;
        }

        const style = `
          <style>
            .select-container {
              margin: 16px 0;
            }
            .multi-select {
              width: 100%;
              padding: 8px;
              border: 1px solid #ddd;
              border-radius: 4px;
              min-height: 100px;
            }
            .multi-select option {
              padding: 4px;
            }
          </style>
        `;

        const products = this._data.map(row => row.product);

        const selectId = this._name || this.getAttribute('name') || 'productSelect';
        const html = `
          ${style}
          <div class="select-container">
            <label for="${selectId}">Select Products:</label><br>
            <select id="${selectId}" name="${this._name}" class="multi-select" multiple>
              ${products.map(product =>
          `<option value="${product}" ${this._selectedValues.includes(product) ? 'selected' : ''}>${product}</option>`
        ).join('')}
            </select>
          </div>
        `;

        this.innerHTML = html;

        // Add event listener for selection changes
        this.querySelector(`#${selectId}`).addEventListener('change', (e) => {
          const select = e.target;
          this._selectedValues = Array.from(select.selectedOptions).map(opt => opt.value);
          // Store the selection in dataStore for queries to use
          // Format as DuckDB array literal: ['Product A','Product B']
          const formattedValues = this._selectedValues.map(v => {
            // escape single quotes by doubling them for SQL
            const safe = v.replace(/'/g, "''");
            return `'${safe}'`;
          });
          dataStore[this._name] = this._selectedValues.length ? `[${formattedValues.join(',')}]` : '[]';
          console.log('Selected products:', dataStore[this._name]); // Debug log
          // Trigger a preview update to refresh queries and components
          updatePreview();
        });
      }
    }
    customElements.define('dropdown-component', Dropdown);

    // Vega-Lite Web Component
    class VegaLiteChart extends HTMLElement {
      static get observedAttributes() { return ['spec', 'data']; }
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this._spec = null;
        this._data = null;
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'spec') {
          try { this._spec = JSON.parse(newValue); } catch { this._spec = null; }
        }
        if (name === 'data') {
          try { this._data = JSON.parse(newValue); } catch { this._data = null; }
        }
        this.renderChart();
      }
      set spec(val) { this._spec = val; this.renderChart(); }
      set data(val) { this._data = val; this.renderChart(); }
      get spec() { return this._spec; }
      get data() { return this._data; }
      connectedCallback() { this.renderChart(); }
      renderChart() {
        if (!this._spec) return;
        const spec = JSON.parse(JSON.stringify(this._spec));
        if (this._data) spec.data = { values: this._data };
        this.shadowRoot.innerHTML = `<div id="chart"></div>`;
        vegaEmbed(this.shadowRoot.querySelector('#chart'), spec);
      }
    }
    customElements.define('vegalite-chart', VegaLiteChart);
    import * as duckdb from '@duckdb/duckdb-wasm';

    // Global store for SQL query results
    const dataStore = {
      productSelection: '[]' // Initialize empty selection
    };

    // Initialize DuckDB
    let db = null;
    let conn = null;

    async function initDuckDB() {
      try {
        const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
        // Select a bundle based on browser checks
        const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);

        const worker_url = URL.createObjectURL(
          new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
        );

        const worker = new Worker(worker_url);
        const logger = new duckdb.ConsoleLogger();
        db = new duckdb.AsyncDuckDB(logger, worker);
        await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
        URL.revokeObjectURL(worker_url);

        conn = await db.connect();
        console.log('DuckDB initialized successfully');
      } catch (error) {
        console.error('DuckDB initialization error:', error);
        throw error;
      }
    }

    // Execute SQL query
    async function executeSQL(sql) {
      if (!conn) {
        throw new Error('DuckDB not initialized');
      }
      const result = await conn.query(sql);
      return result.toArray().map(row => row.toJSON());
    }

    // Custom Web Components
    // Vega-Lite chart component for SQL data
    // Usage: <vegalite-chart spec='...' data='${queryName}'></vegalite-chart>
    class SampleTable extends HTMLElement {
      connectedCallback() {
        this.render();
      }

      render() {
        const dataAttr = this.getAttribute('data');
        if (!dataAttr) {
          this.innerHTML = '<p style="color: #999;">No data provided</p>';
          return;
        }

        const data = dataStore[dataAttr.replace(/[${}]/g, '')];
        if (!data || !Array.isArray(data) || data.length === 0) {
          this.innerHTML = '<p style="color: #999;">Data not available or empty</p>';
          return;
        }

        const columns = Object.keys(data[0]);
        const html = `
          <div style="border: 1px solid #ddd; border-radius: 4px; overflow: hidden; margin: 16px 0;">
            <table style="width: 100%; border-collapse: collapse;">
              <thead>
                <tr style="background: #f8f9fa;">
                  ${columns.map(col => `<th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; font-weight: 600;">${col}</th>`).join('')}
                </tr>
              </thead>
              <tbody>
                ${data.map(row => `
                  <tr style="border-bottom: 1px solid #eee;">
                    ${columns.map(col => `<td style="padding: 10px;">${row[col]}</td>`).join('')}
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        `;
        this.innerHTML = html;
      }
    }

    class DataCard extends HTMLElement {
      connectedCallback() {
        this.render();
      }

      render() {
        const dataAttr = this.getAttribute('data');
        if (!dataAttr) {
          this.innerHTML = '<p style="color: #999;">No data provided</p>';
          return;
        }

        const data = dataStore[dataAttr.replace(/[${}]/g, '')];
        if (!data || !Array.isArray(data) || data.length === 0) {
          this.innerHTML = '<p style="color: #999;">Data not available</p>';
          return;
        }

        const record = data[0];
        const html = `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin: 16px 0;">
            ${Object.entries(record).map(([key, value]) => `
              <div style="border: 1px solid #ddd; border-radius: 8px; padding: 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                <div style="color: rgba(255,255,255,0.8); font-size: 12px; text-transform: uppercase; margin-bottom: 8px;">${key.replace(/_/g, ' ')}</div>
                <div style="color: white; font-size: 24px; font-weight: 700;">${typeof value === 'number' ? value.toLocaleString() : value}</div>
              </div>
            `).join('')}
          </div>
        `;
        this.innerHTML = html;
      }
    }

    customElements.define('data-table-component', SampleTable);
    customElements.define('data-card', DataCard);

    // Parse SQL code blocks and extract name
    function parseSQLBlock(code, infoString) {
      const nameMatch = infoString.match(/name=['"]([^'"]+)['"]/);
      return {
        code,
        name: nameMatch ? nameMatch[1] : null
      };
    }

    // Render SQL results as HTML
    function renderSQLResult(data, queryName, error = null) {
      if (error) {
        return `<div class="sql-error"><strong>SQL Error:</strong> ${error}</div>`;
      }

      if (!data || data.length === 0) {
        return `<details class="sql-result" open>
          <summary>Query Result${queryName ? `: ${queryName}` : ''} (0 rows)</summary>
          <div class="sql-result-content"><p style="color: #999;">No results returned</p></div>
        </details>`;
      }

      const columns = Object.keys(data[0]);
      const tableHTML = `
        <table>
          <thead>
            <tr>${columns.map(col => `<th>${col}</th>`).join('')}</tr>
          </thead>
          <tbody>
            ${data.map(row => `
              <tr>${columns.map(col => `<td>${row[col] !== null ? row[col] : '<em>null</em>'}</td>`).join('')}</tr>
            `).join('')}
          </tbody>
        </table>
      `;

      return `<details class="sql-result" open>
        <summary>Query Result${queryName ? `: ${queryName}` : ''} (${data.length} rows)</summary>
        <div class="sql-result-content">${tableHTML}</div>
      </details>`;
    }

    // Process markdown and execute SQL
    async function processMarkdown(markdown) {
      const sqlBlocks = [];
      let blockIndex = 0;

      // Replace SQL blocks with HTML-comment placeholders and store them
      // Using HTML comments prevents Markdown (e.g. __bold__) from altering the token
      // Support both multi-line and single-line SQL code blocks
      let processedMarkdown = markdown.replace(
        /```sql([^\n]*)\n([\s\S]*?)```|```sql([^`]+)```/g,
        (match, infoString, code, singleLine) => {
          let parsed;
          if (singleLine) {
            parsed = parseSQLBlock(singleLine.trim(), infoString || "");
          } else {
            parsed = parseSQLBlock(code.trim(), infoString || "");
          }
          // Use an HTML comment as placeholder so marked won't treat underscores as emphasis
          const placeholder = `<!--SQL_BLOCK_${blockIndex}-->`;
          sqlBlocks.push({ ...parsed, placeholder });
          blockIndex++;
          return placeholder;
        }
      );

      // Convert markdown to HTML
      let html = marked.parse(processedMarkdown);

      // Execute SQL blocks and replace placeholders
      for (const block of sqlBlocks) {
        let resultHTML;
        try {
          // Replace ${var} tokens inside SQL with values from dataStore
          let codeToExecute = block.code.replace(/\$\{(\w+)\}/g, (m, varName) => {
            const val = dataStore[varName];
            if (val === undefined) return 'NULL';
            // If value already looks like a DuckDB array literal (starts with [), inject as-is
            if (typeof val === 'string' && val.trim().startsWith('[')) return val;
            // For arrays/objects, inject JSON representation
            if (Array.isArray(val) || typeof val === 'object') return JSON.stringify(val);
            // Otherwise inject primitive as literal
            if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
            return String(val);
          });

          console.log('Executing SQL for block', block.name, ':', codeToExecute);
          const data = await executeSQL(codeToExecute);

          if (block.name) {
            dataStore[block.name] = data;
          }

          resultHTML = `<pre><code class="language-sql">${block.code}</code></pre>` +
            renderSQLResult(data, block.name);
          console.log(`Data stored for ${block.name}:`, data); // Debugging
        } catch (error) {
          resultHTML = `<pre><code class="language-sql">${block.code}</code></pre>` +
            renderSQLResult(null, block.name, error.message);
        }

        // Replace the HTML-comment placeholder with the generated result HTML
        html = html.replace(block.placeholder, resultHTML);
      }

      // Replace variable references in web components
      html = html.replace(/\$\{(\w+)\}/g, (match, varName) => {
        return varName;
      });

      return html;
    }

    // Render web components after HTML is inserted
    function renderWebComponents() {
      const preview = document.getElementById('preview');
      const components = preview.querySelectorAll('data-table-component, data-card, vegalite-chart');
      components.forEach(component => {
        if (component.tagName === 'VEGALITE-CHART') {
          // If data attribute is a query name, replace with actual data
          const dataAttr = component.getAttribute('data');
          if (dataAttr && dataStore[dataAttr]) {
            component.data = dataStore[dataAttr];
          }
        }
      });
      components.forEach(component => {
        if (component.render) {
          component.render();
        }
      });
    }

    // Update preview
    async function updatePreview() {
      const markdown = editor.getValue();
      const preview = document.getElementById('preview');

      try {
        const html = await processMarkdown(markdown);
        preview.innerHTML = html;

        // Re-render web components after a short delay to ensure data is available
        setTimeout(renderWebComponents, 100);
      } catch (error) {
        console.error('Error processing markdown:', error);
        preview.innerHTML = `<div class="sql-error">Error: ${error.message}</div>`;
      }
    }

    // Initialize CodeMirror
    const editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
      mode: 'markdown',
      theme: 'monokai',
      lineNumbers: true,
      lineWrapping: true,
      autofocus: true
    });

    // Initialize DuckDB and set up editor change listener
    initDuckDB().then(() => {
      let debounceTimer;
      editor.on('change', () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(updatePreview, 300);
      });

      // Initial render
      updatePreview();
    }).catch(error => {
      console.error('Failed to initialize DuckDB:', error);
      document.getElementById('preview').innerHTML =
        `<div class="sql-error">Failed to initialize DuckDB: ${error.message}<br><br>This may be due to browser security restrictions. Try opening this page in a local server or different browser.</div>`;
    });
  </script>
</body>

</html>