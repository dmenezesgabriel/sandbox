<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Markdown Preview - Optimized</title>

  <script type="importmap">
    {
      "imports": {
        "lit": "https://esm.sh/lit@3.1.0",
        "lit/": "https://esm.sh/lit@3.1.0/",
        "codemirror": "https://esm.sh/*codemirror@6.0.1",
        "@codemirror/": "https://esm.sh/*@codemirror/",
        "@lezer/": "https://esm.sh/*@lezer/",
        "style-mod": "https://esm.sh/style-mod",
        "w3c-keyname": "https://esm.sh/w3c-keyname",
        "crelt": "https://esm.sh/crelt",
        "@marijn/find-cluster-break": "https://esm.sh/@marijn/find-cluster-break",
        "marked": "https://esm.sh/marked@16.0.0",
        "vega": "https://cdn.jsdelivr.net/npm/vega@6.2.0/+esm",
        "vega-lite": "https://cdn.jsdelivr.net/npm/vega-lite@6.4.1/+esm",
        "vega-embed": "https://cdn.jsdelivr.net/npm/vega-embed@7.1.0/+esm",
        "@duckdb/duckdb-wasm": "https://esm.sh/@duckdb/duckdb-wasm@1.30.0",
        "gray-matter": "https://cdn.jsdelivr.net/npm/gray-matter@4.0.3/+esm"
      }
    }
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      height: 100vh;
      overflow: hidden;
    }

    #root {
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="module">
    import { LitElement, html, css } from "lit";
    import { basicSetup, EditorView } from "codemirror";
    import { EditorState } from "@codemirror/state";
    import { markdown } from "@codemirror/lang-markdown";
    import { marked } from "marked";
    import vegaEmbed from "vega-embed";
    import * as duckdb from '@duckdb/duckdb-wasm';
    import matter from "gray-matter";

    // ============================================================================
    // UTILITIES
    // ============================================================================

    /**
     * Debounce utility to delay function execution
     */
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    /**
     * Safe JSON parser that returns default value on error
     */
    function safeJsonParse(jsonString, defaultValue = null) {
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        console.error('Invalid JSON:', e);
        return defaultValue;
      }
    }

    /**
     * Extract input variable names from code string
     * @param {string} code - Code containing ${input.xxx} references
     * @returns {string[]} - Array of unique input names
     */
    function extractInputNames(code) {
      const inputRefs = code.match(/\$\{input\.(\w+)\}/g);
      if (!inputRefs) return [];
      return [...new Set(inputRefs.map(ref => ref.match(/\$\{input\.(\w+)\}/)[1]))];
    }

    // ============================================================================
    // STORE MANAGER
    // ============================================================================

    const store = {
      data: {},
      input: {},
      frontmatter: {}
    };

    const storeManager = {
      listeners: new Map(),

      setState(path, value) {
        const [category, key] = path.split('.');
        if (category === 'data' || category === 'input' || category === 'frontmatter') {
          if (JSON.stringify(store[category][key]) === JSON.stringify(value)) {
            return;
          }
          store[category][key] = value;
          console.log(`[store] setState(${path}):`, value);
          this.notify(path, value);
        }
      },

      getState(path) {
        const [category, key] = path.split('.');
        return store[category]?.[key];
      },

      subscribe(path, callback) {
        if (!this.listeners.has(path)) {
          this.listeners.set(path, new Set());
        }
        this.listeners.get(path).add(callback);

        return () => {
          const callbacks = this.listeners.get(path);
          if (callbacks) {
            callbacks.delete(callback);
            if (callbacks.size === 0) {
              this.listeners.delete(path);
            }
          }
        };
      },

      notify(path, value) {
        console.log(`[store] notify(${path}) - ${this.listeners.get(path)?.size || 0} listeners`);
        const callbacks = this.listeners.get(path);
        if (callbacks) {
          callbacks.forEach(cb => cb(value));
        }

        const [category] = path.split('.');
        const wildcardPath = `${category}.*`;
        const wildcardCallbacks = this.listeners.get(wildcardPath);
        if (wildcardCallbacks) {
          console.log(`[store] notify wildcard(${wildcardPath}) - ${wildcardCallbacks.size} listeners`);
          wildcardCallbacks.forEach(cb => cb(value, path));
        }
      }
    };

    // ============================================================================
    // DUCKDB MANAGER
    // ============================================================================

    class DuckDBManager {
      constructor() {
        this.dbInstance = null;
        this.dbConnection = null;
      }

      async initialize() {
        if (this.dbInstance) return this.dbInstance;

        const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
        const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
        const worker_url = URL.createObjectURL(
          new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
        );
        const worker = new Worker(worker_url);
        const logger = new duckdb.ConsoleLogger();
        const db = new duckdb.AsyncDuckDB(logger, worker);
        await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
        URL.revokeObjectURL(worker_url);

        this.dbInstance = db;
        this.dbConnection = await db.connect();
        return db;
      }

      async getConnection() {
        await this.initialize();
        return this.dbConnection;
      }

      async query(sql) {
        const connection = await this.getConnection();
        return connection.query(sql);
      }
    }

    const duckDBManager = new DuckDBManager();

    // ============================================================================
    // INITIAL LOAD TRACKER
    // ============================================================================

    class InitialLoadTracker {
      constructor() {
        this.pendingItems = new Set();
        this.isComplete = false;
        this.completionCallbacks = [];
      }

      addPending(name) {
        if (!this.isComplete && name) {
          this.pendingItems.add(name);
        }
      }

      markComplete(name) {
        if (!name) return;

        this.pendingItems.delete(name);

        if (this.pendingItems.size === 0 && !this.isComplete) {
          this.isComplete = true;
          console.log('[InitialLoadTracker] All items loaded, marking complete');
          this.notifyCompletion();
        }
      }

      isLoadComplete() {
        return this.isComplete;
      }

      onComplete(callback) {
        if (this.isComplete) {
          callback();
        } else {
          this.completionCallbacks.push(callback);
        }
      }

      notifyCompletion() {
        this.completionCallbacks.forEach(cb => cb());
        this.completionCallbacks = [];
      }
    }

    const initialLoadTracker = new InitialLoadTracker();

    // ============================================================================
    // INPUT SUBSCRIPTION MANAGER
    // ============================================================================

    class InputSubscriptionManager {
      constructor(componentName, code, onInputChange) {
        this.componentName = componentName;
        this.code = code;
        this.onInputChange = onInputChange;
        this.unsubscribers = [];
      }

      subscribe() {
        const inputNames = extractInputNames(this.code);

        if (inputNames.length > 0) {
          console.log(`[${this.componentName}] Subscribing to inputs:`, inputNames);

          inputNames.forEach(inputName => {
            const unsubscribe = storeManager.subscribe(`input.${inputName}`, () => {
              console.log(`[${this.componentName}] Input ${inputName} changed`);
              this.onInputChange(inputName);
            });
            this.unsubscribers.push(unsubscribe);
          });
        }

        return this;
      }

      unsubscribe() {
        this.unsubscribers.forEach(unsub => unsub());
        this.unsubscribers = [];
      }
    }

    // ============================================================================
    // CACHE MANAGER
    // ============================================================================

    class CacheManager {
      constructor(cacheName) {
        this.cacheName = cacheName;
        this.cache = new Map();
      }

      getCacheKey(name, code) {
        return `${name}:${code}`;
      }

      get(name, code) {
        const key = this.getCacheKey(name, code);
        return this.cache.get(key);
      }

      set(name, code, value) {
        const key = this.getCacheKey(name, code);
        this.cache.set(key, value);
        console.log(`[${this.cacheName}] Cached result for ${name}`);
      }

      invalidate(name, code) {
        const key = this.getCacheKey(name, code);
        this.cache.delete(key);
        console.log(`[${this.cacheName}] Invalidated cache for ${name}`);
      }

      has(name, code) {
        const key = this.getCacheKey(name, code);
        return this.cache.has(key);
      }
    }

    const sqlQueryCache = new CacheManager('SQLCache');
    const httpRequestCache = new CacheManager('HTTPCache');

    // ============================================================================
    // EXECUTABLE CODE BLOCK BASE CLASS
    // ============================================================================

    class ExecutableCodeBlock extends LitElement {
      static properties = {
        code: { type: String },
        name: { type: String },
        hide: { type: Boolean },
        result: { type: Object },
        _hasExecuted: { state: true }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        .code-block {
          background: #f5f5f5;
          padding: 12px;
          border-radius: 4px;
          overflow-x: auto;
          margin-bottom: 12px;
        }
        pre {
          margin: 0;
          font-family: monospace;
          font-size: 14px;
        }
        .header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
          font-size: 12px;
          color: #666;
        }
        .status {
          padding: 4px 8px;
          border-radius: 3px;
          font-size: 11px;
        }
        .loading { background: #fff3cd; }
        .success { background: #d4edda; }
        .error { background: #f8d7da; color: #721c24; }
      `;

      constructor() {
        super();
        this.code = '';
        this.name = '';
        this.hide = false;
        this.result = null;
        this.status = 'loading';
        this.error = null;
        this._hasExecuted = false;
        this.inputSubscriptionManager = null;
        this.debouncedExecute = debounce(() => this.executeWithCacheInvalidation(), 300);
      }

      connectedCallback() {
        super.connectedCallback();
        this.setupExecution();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.cleanup();
      }

      setupExecution() {
        const cached = this.getCachedResult();

        if (cached) {
          this.applyCachedResult(cached);
          this.setupInputSubscriptions();
          return;
        }

        initialLoadTracker.addPending(this.name);
        this.setupInputSubscriptions();

        if (this.shouldExecuteImmediately()) {
          this.execute();
        }
      }

      applyCachedResult(cached) {
        console.log(`[${this.name}] Using cached results`);
        this.result = cached.result;
        this.status = cached.status;
        this.error = cached.error;
        this.onCachedResultApplied(cached);
        this._hasExecuted = true;
        this.requestUpdate();
      }

      setupInputSubscriptions() {
        this.inputSubscriptionManager = new InputSubscriptionManager(
          this.name,
          this.code,
          () => this.onInputChanged()
        );
        this.inputSubscriptionManager.subscribe();
      }

      onInputChanged() {
        console.log(`[${this.name}] Input changed, re-executing`);
        this.invalidateCache();
        this.debouncedExecute();
      }

      executeWithCacheInvalidation() {
        this.invalidateCache();
        this.execute();
      }

      async execute() {
        this.status = 'loading';
        this.requestUpdate();

        try {
          this.result = await this.performExecution();
          this.status = 'success';
          this._hasExecuted = true;

          this.cacheResult();
          this.storeResult();
          await this.onExecutionSuccess();
        } catch (e) {
          this.error = e.message;
          this.status = 'error';
          this.cacheError(e);
          console.error(`[${this.name}] Execution error:`, e);
        } finally {
          initialLoadTracker.markComplete(this.name);
          this.requestUpdate();
        }
      }

      cacheResult() {
        this.getCacheManager().set(this.name, this.code, {
          result: this.result,
          status: this.status,
          error: null
        });
      }

      cacheError(error) {
        this.getCacheManager().set(this.name, this.code, {
          result: null,
          status: 'error',
          error: error.message
        });
      }

      invalidateCache() {
        this.getCacheManager().invalidate(this.name, this.code);
      }

      storeResult() {
        if (this.name && this.result !== null) {
          const existingData = storeManager.getState(`data.${this.name}`);
          if (!existingData || JSON.stringify(existingData) !== JSON.stringify(this.result)) {
            console.log(`[${this.name}] Storing result in store`);
            storeManager.setState(`data.${this.name}`, this.result);
          }
        }
      }

      cleanup() {
        if (this.inputSubscriptionManager) {
          this.inputSubscriptionManager.unsubscribe();
        }
      }

      renderStatusBadge() {
        if (!this.name) return '';

        return html`
          <div class="header">
            <strong>${this.name}</strong>
            <span class="status ${this.status}">
              ${this.getStatusText()}
            </span>
          </div>
        `;
      }

      renderError() {
        if (this.status !== 'error') return '';

        return html`
          <div class="error" style="padding: 8px; margin-top: 8px;">
            ${this.error}
          </div>
        `;
      }

      renderCodeBlock() {
        return html`
          <div class="code-block">
            <pre><code>${this.code}</code></pre>
          </div>
        `;
      }

      // Abstract methods to be implemented by subclasses
      getCacheManager() {
        throw new Error('getCacheManager() must be implemented by subclass');
      }

      getCachedResult() {
        throw new Error('getCachedResult() must be implemented by subclass');
      }

      shouldExecuteImmediately() {
        return true;
      }

      async performExecution() {
        throw new Error('performExecution() must be implemented by subclass');
      }

      getStatusText() {
        return this.status === 'loading' ? 'Executing...' :
          this.status === 'success' ? 'Success' : 'Error';
      }

      onCachedResultApplied(cached) {
        // Hook for subclasses to perform additional actions
      }

      async onExecutionSuccess() {
        // Hook for subclasses to perform additional actions after successful execution
      }

      render() {
        if (this.hide) return html``;

        return html`
          <div>
            ${this.renderStatusBadge()}
            ${this.renderCodeBlock()}
            ${this.renderError()}
            ${this.renderResult()}
          </div>
        `;
      }

      renderResult() {
        return '';
      }
    }

    // ============================================================================
    // SQL CODE BLOCK
    // ============================================================================

    class SqlCodeBlock extends ExecutableCodeBlock {
      static properties = {
        ...ExecutableCodeBlock.properties,
        dependson: { type: String }
      };

      constructor() {
        super();
        this.dependson = '[]';
        this._pendingDependencies = new Set();
        this._tableInsertedHandler = null;
      }

      connectedCallback() {
        super.connectedCallback();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._tableInsertedHandler) {
          document.removeEventListener('table-inserted', this._tableInsertedHandler);
        }
      }

      shouldExecuteImmediately() {
        const dependencies = safeJsonParse(this.dependson, []);

        if (dependencies.length > 0) {
          this._pendingDependencies = new Set(dependencies);
          console.log(`[${this.name}] Waiting for dependencies:`, dependencies);

          this._tableInsertedHandler = (e) => {
            const tableName = e.detail?.tableName;
            if (tableName && this._pendingDependencies.has(tableName)) {
              console.log(`[${this.name}] Dependency ${tableName} resolved`);
              this._pendingDependencies.delete(tableName);

              if (this._pendingDependencies.size === 0) {
                console.log(`[${this.name}] All dependencies resolved, executing query`);
                // Add to pending tracking before execution
                initialLoadTracker.addPending(this.name);
                this.execute();
              }
            }
          };

          document.addEventListener('table-inserted', this._tableInsertedHandler);
          return false;
        }

        return true;
      }

      getCacheManager() {
        return sqlQueryCache;
      }

      getCachedResult() {
        return sqlQueryCache.get(this.name, this.code);
      }

      async performExecution() {
        await duckDBManager.initialize();

        const processedCode = this.code.replace(/\$\{input\.(\w+)\}/g, (match, inputName) => {
          const value = storeManager.getState(`input.${inputName}`);
          if (!value || (Array.isArray(value) && value.length === 0)) {
            return '[]';
          }
          return `['${value.join("','")}']`;
        });

        console.log(`[${this.name}] Executing query with processed code:`, processedCode);

        const queryResult = await duckDBManager.query(processedCode);
        return queryResult.toArray().map(row => row.toJSON());
      }

      getStatusText() {
        if (this.status === 'loading') return 'Executing...';
        if (this.status === 'success') return `${this.result?.length || 0} rows`;
        return 'Error';
      }

      renderResult() {
        if (this.status !== 'success' || !this.result || this.result.length === 0) {
          return '';
        }

        const keys = Object.keys(this.result[0]);

        return html`
          <details open style="margin-top: 12px;">
            <summary style="cursor: pointer; padding: 8px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-weight: 600;">
              Query Results (${this.result.length} rows)
            </summary>
            <table style="width: 100%; border-collapse: collapse; margin-top: 8px;">
              <thead>
                <tr>
                  ${keys.map(key => html`<th style="padding: 8px; text-align: left; border: 1px solid #ddd; background: #f5f5f5; font-weight: 600;">${key}</th>`)}
                </tr>
              </thead>
              <tbody>
                ${this.result.map(row => html`
                  <tr>
                    ${keys.map(key => html`<td style="padding: 8px; text-align: left; border: 1px solid #ddd;">${row[key]}</td>`)}
                  </tr>
                `)}
              </tbody>
            </table>
          </details>
        `;
      }
    }

    // ============================================================================
    // HTTP CODE BLOCK
    // ============================================================================

    class HttpCodeBlock extends ExecutableCodeBlock {
      static properties = {
        ...ExecutableCodeBlock.properties,
        insert: { type: Boolean },
        onaction: { type: String }
      };

      static styles = css`
        ${ExecutableCodeBlock.styles}
        .json-result {
          background: #282c34;
          color: #abb2bf;
          padding: 16px;
          border-radius: 4px;
          overflow-x: auto;
          margin-top: 12px;
          font-family: monospace;
          font-size: 13px;
          line-height: 1.5;
        }
        .json-key { color: #e06c75; }
        .json-string { color: #98c379; }
        .json-number { color: #d19a66; }
        .json-boolean { color: #56b6c2; }
        .json-null { color: #c678dd; }
      `;

      constructor() {
        super();
        this.insert = false;
        this.onaction = '';
        this.responseStatus = null;
        this._actionTriggerHandler = null;
      }

      connectedCallback() {
        super.connectedCallback();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._actionTriggerHandler) {
          document.removeEventListener('action-trigger', this._actionTriggerHandler);
        }
      }

      connectedCallback() {
        super.connectedCallback();

        // Set up action trigger listener if needed
        if (this.onaction) {
          this.setupActionTrigger();
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._actionTriggerHandler) {
          document.removeEventListener('action-trigger', this._actionTriggerHandler);
          this._actionTriggerHandler = null;
        }
      }

      setupActionTrigger() {
        // Remove any existing handler first
        if (this._actionTriggerHandler) {
          document.removeEventListener('action-trigger', this._actionTriggerHandler);
        }

        console.log(`[${this.name}] Setting up action trigger for: ${this.onaction}`);

        this._actionTriggerHandler = (e) => {
          const actionName = e.detail?.name;
          if (actionName === this.onaction) {
            console.log(`[${this.name}] Action ${actionName} triggered, executing request`);
            this.execute();
          }
        };

        document.addEventListener('action-trigger', this._actionTriggerHandler);
      }

      shouldExecuteImmediately() {
        // If onAction is specified, don't execute immediately
        if (this.onaction) {
          console.log(`[${this.name}] Waiting for action trigger: ${this.onaction}`);
          // Remove from initial load tracking since it won't execute immediately
          initialLoadTracker.markComplete(this.name);
          return false;
        }

        return true;
      }

      setupInputSubscriptions() {
        const inputRefs = extractInputNames(this.code);

        if (inputRefs.length > 0) {
          console.log(`[${this.name}] Found input references in HTTP body:`, inputRefs);
          this.inputSubscriptionManager = new InputSubscriptionManager(
            this.name,
            this.code,
            () => {
              // Don't auto-execute on input change if waiting for action
              if (!this.onaction) {
                this.onInputChanged();
              } else {
                console.log(`[${this.name}] Input changed but waiting for action: ${this.onaction}`);
              }
            }
          );
          this.inputSubscriptionManager.subscribe();
        }
      }

      getCacheManager() {
        return httpRequestCache;
      }

      getCachedResult() {
        const cached = httpRequestCache.get(this.name, this.code);
        if (cached) {
          this.responseStatus = cached.responseStatus;
        }
        return cached;
      }

      onCachedResultApplied(cached) {
        this.responseStatus = cached.responseStatus;

        if (this.insert && this.status === 'success') {
          setTimeout(() => {
            this.insertIntoDuckDB();
          }, 0);
        }
      }

      parseHttpRequest() {
        const lines = this.code.trim().split('\n');
        let requestLine = '';
        const headers = {};
        let body = null;
        let inBody = false;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          if (!line && !inBody && requestLine) {
            inBody = true;
            continue;
          }

          if (!requestLine && line.match(/^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)/i)) {
            requestLine = line;
          } else if (!inBody && line.includes(':')) {
            const [key, ...valueParts] = line.split(':');
            headers[key.trim()] = valueParts.join(':').trim();
          } else if (inBody && line) {
            if (body === null) body = '';
            body += line + '\n';
          }
        }

        const requestMatch = requestLine.match(/^(\w+)\s+(.+?)(?:\s+HTTP\/[\d.]+)?$/i);
        if (!requestMatch) throw new Error('Invalid request line format');

        const [, method, url] = requestMatch;
        return {
          method: method.toUpperCase(),
          url: url.trim(),
          headers,
          body: body ? body.trim() : null
        };
      }

      async performExecution() {
        const { method, url, headers, body } = this.parseHttpRequest();
        const fetchOptions = { method, headers: {} };

        Object.entries(headers).forEach(([key, value]) => {
          fetchOptions.headers[key] = value;
        });

        // Process body with input variable substitution
        let processedBody = body;
        if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
          processedBody = body.replace(/\$\{input\.(\w+)\}/g, (match, inputName) => {
            const value = storeManager.getState(`input.${inputName}`);
            if (value === null || value === undefined) {
              return '';
            }
            // If it's an array with single value (from dropdown), use first value
            if (Array.isArray(value) && value.length === 1) {
              return value[0];
            }
            // If it's an array with multiple values, join them
            if (Array.isArray(value)) {
              return value.join(', ');
            }
            return String(value);
          });
          fetchOptions.body = processedBody;
        }

        console.log(`[${this.name || 'http'}] Executing ${method} ${url}`);
        if (processedBody) {
          console.log(`[${this.name || 'http'}] Request body:`, processedBody);
        }

        const response = await fetch(url, fetchOptions);
        this.responseStatus = response.status;

        const contentType = response.headers.get('content-type');
        let data;

        if (contentType && contentType.includes('application/json')) {
          data = await response.json();
        } else {
          data = await response.text();
        }

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return data;
      }

      async onExecutionSuccess() {
        if (this.insert) {
          await this.insertIntoDuckDB();
        }
      }

      cacheResult() {
        this.getCacheManager().set(this.name, this.code, {
          result: this.result,
          status: this.status,
          error: null,
          responseStatus: this.responseStatus
        });
      }

      cacheError(error) {
        this.getCacheManager().set(this.name, this.code, {
          result: null,
          status: 'error',
          error: error.message,
          responseStatus: this.responseStatus
        });
      }

      async insertIntoDuckDB() {
        if (!this.name || !this.result) return;

        try {
          await duckDBManager.initialize();

          const dataArray = Array.isArray(this.result) ? this.result : [this.result];

          if (dataArray.length === 0) {
            console.warn(`[${this.name}] Cannot insert empty array into DuckDB`);
            return;
          }

          try {
            await duckDBManager.query(`DROP TABLE IF EXISTS ${this.name}`);
          } catch (e) {
            // Ignore errors from dropping non-existent tables
          }

          const firstRow = dataArray[0];
          const columns = Object.keys(firstRow).map(key => {
            const value = firstRow[key];
            let sqlType = 'VARCHAR';

            if (typeof value === 'number') {
              sqlType = Number.isInteger(value) ? 'INTEGER' : 'DOUBLE';
            } else if (typeof value === 'boolean') {
              sqlType = 'BOOLEAN';
            }

            return `${key} ${sqlType}`;
          }).join(', ');

          await duckDBManager.query(`CREATE TABLE ${this.name} (${columns})`);

          for (const row of dataArray) {
            const values = Object.values(row).map(val => {
              if (val === null || val === undefined) return 'NULL';
              if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
              if (typeof val === 'boolean') return val ? 'true' : 'false';
              return val;
            }).join(', ');

            await duckDBManager.query(`INSERT INTO ${this.name} VALUES (${values})`);
          }

          console.log(`[${this.name}] Inserted ${dataArray.length} rows into DuckDB table`);

          this.dispatchEvent(new CustomEvent('table-inserted', {
            detail: { tableName: this.name },
            bubbles: true,
            composed: true
          }));

        } catch (e) {
          console.error(`[${this.name}] Error inserting into DuckDB:`, e);
          this.error = `DuckDB insert failed: ${e.message}`;
          this.requestUpdate();
        }
      }

      getStatusText() {
        if (this.status === 'loading') return 'Executing...';
        if (this.status === 'success') return `HTTP ${this.responseStatus}`;
        return 'Error';
      }

      syntaxHighlightJson(json) {
        if (typeof json !== 'string') json = JSON.stringify(json, null, 2);
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match) => {
          let cls = 'json-number';
          if (/^"/.test(match)) {
            cls = /:$/.test(match) ? 'json-key' : 'json-string';
          } else if (/true|false/.test(match)) {
            cls = 'json-boolean';
          } else if (/null/.test(match)) {
            cls = 'json-null';
          }
          return `<span class="${cls}">${match}</span>`;
        });
      }

      renderResult() {
        if (this.status !== 'success' || !this.result) return '';

        return html`
          <details open>
            <summary style="cursor: pointer; padding: 8px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-weight: 600; margin-bottom: 8px;">
              Response (HTTP ${this.responseStatus})
            </summary>
            <div class="json-result">
              <pre .innerHTML=${this.syntaxHighlightJson(this.result)}></pre>
            </div>
          </details>
        `;
      }
    }

    // ============================================================================
    // TEXT INPUT
    // ============================================================================

    class TextInput extends LitElement {
      static properties = {
        name: { type: String },
        label: { type: String },
        placeholder: { type: String },
        value: { type: String }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        .input-container {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        label {
          font-weight: 600;
          font-size: 14px;
        }
        input {
          padding: 8px 12px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
          font-family: inherit;
        }
        input:focus {
          outline: none;
          border-color: #4a90e2;
          box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }
      `;

      constructor() {
        super();
        this.name = '';
        this.label = '';
        this.placeholder = '';
        this.value = '';
      }

      handleInput(e) {
        this.value = e.target.value;

        console.log(`[text-input:${this.name}] Value changed:`, this.value);

        this.dispatchEvent(new CustomEvent('value-change', {
          detail: {
            name: this.name,
            value: this.value
          },
          bubbles: true,
          composed: true
        }));
      }

      render() {
        return html`
          <div class="input-container">
            ${this.label ? html`<label for=${this.name}>${this.label}</label>` : ''}
            <input
              id=${this.name}
              type="text"
              .value=${this.value}
              placeholder=${this.placeholder || ''}
              @input=${this.handleInput}
            />
          </div>
        `;
      }
    }

    // ============================================================================
    // ACTION BUTTON
    // ============================================================================

    class ActionButton extends LitElement {
      static properties = {
        name: { type: String },
        label: { type: String },
        disabled: { type: Boolean }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        button {
          padding: 10px 20px;
          background: #4a90e2;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          font-family: inherit;
          transition: background 0.2s;
        }
        button:hover:not(:disabled) {
          background: #357abd;
        }
        button:active:not(:disabled) {
          background: #2868a8;
        }
        button:disabled {
          background: #ccc;
          cursor: not-allowed;
        }
      `;

      constructor() {
        super();
        this.name = '';
        this.label = 'Submit';
        this.disabled = false;
      }

      handleClick() {
        if (this.disabled) return;

        console.log(`[action-button:${this.name}] Button clicked`);

        this.dispatchEvent(new CustomEvent('action-trigger', {
          detail: {
            name: this.name
          },
          bubbles: true,
          composed: true
        }));
      }

      render() {
        return html`
          <button
            ?disabled=${this.disabled}
            @click=${this.handleClick}>
            ${this.label}
          </button>
        `;
      }
    }

    // ============================================================================
    // DROPDOWN SELECT
    // ============================================================================

    class DropdownSelect extends LitElement {
      static properties = {
        data: { type: String },
        name: { type: String },
        label: { type: String },
        multiple: { type: Boolean },
        selected: { type: Array }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        .select-container {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        label {
          font-weight: 600;
          font-size: 14px;
        }
        select {
          padding: 8px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
          background: white;
          min-height: 40px;
        }
        select[multiple] {
          min-height: 120px;
        }
      `;

      constructor() {
        super();
        this.data = '[]';
        this.name = '';
        this.label = '';
        this.multiple = true;
        this.selected = [];
      }

      handleChange(e) {
        const selectElement = e.target;
        if (this.multiple) {
          this.selected = Array.from(selectElement.selectedOptions).map(opt => opt.value);
        } else {
          this.selected = [selectElement.value];
        }

        console.log(`[dropdown-select:${this.name}] Selection changed:`, this.selected);

        this.dispatchEvent(new CustomEvent('value-change', {
          detail: {
            name: this.name,
            value: this.selected
          },
          bubbles: true,
          composed: true
        }));
      }

      render() {
        const options = safeJsonParse(this.data, []);

        const values = options.map(opt => {
          if (typeof opt === 'string') return opt;
          return Object.values(opt)[0];
        });

        return html`
          <div class="select-container">
            ${this.label ? html`<label>${this.label}</label>` : ''}
            <select
              ?multiple=${this.multiple}
              @change=${this.handleChange}>
              ${values.map(val => html`
                <option value=${val} ?selected=${this.selected.includes(val)}>
                  ${val}
                </option>
              `)}
            </select>
          </div>
        `;
      }
    }

    // ============================================================================
    // VEGA-LITE CHART
    // ============================================================================

    class VegaLiteChart extends LitElement {
      static properties = {
        spec: { type: String }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        #chart { width: 100%; }
        .empty { color: #999; padding: 12px; }
        .error { color: #c33; padding: 8px; }
      `;

      constructor() {
        super();
        this.spec = null;
        this._lastSpec = '';
      }

      updated(changedProperties) {
        if (changedProperties.has("spec") && this.spec !== this._lastSpec) {
          this._lastSpec = this.spec;
          this.renderChart();
        }
      }

      async renderChart() {
        const chartDiv = this.renderRoot.querySelector("#chart");
        if (!chartDiv) return;

        if (!this.spec) {
          chartDiv.innerHTML = '<div class="empty">No chart spec provided</div>';
          return;
        }

        const specObj = safeJsonParse(this.spec);
        if (!specObj) {
          chartDiv.innerHTML = '<div class="error">Invalid spec JSON</div>';
          return;
        }

        try {
          await vegaEmbed(chartDiv, specObj, { actions: false });
        } catch (e) {
          console.error("vegaEmbed error:", e);
          chartDiv.innerHTML = '<div class="error">Chart render error</div>';
        }
      }

      render() {
        return html`<div id="chart"></div>`;
      }
    }

    // ============================================================================
    // DATA TABLE
    // ============================================================================

    class DataTable extends LitElement {
      static properties = {
        data: { type: String },
        columnConfig: { type: String },
        dataArray: { type: Array },
        autoColumns: { type: String }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        table {
          width: 100%;
          border-collapse: collapse;
        }
        th, td {
          padding: 8px;
          text-align: left;
          border: 1px solid #ddd;
        }
        th {
          background: #f5f5f5;
          font-weight: 600;
        }
      `;

      constructor() {
        super();
        this.data = '[]';
        this.columnConfig = '[]';
        this.dataArray = null;
        this.autoColumns = 'false';
      }

      render() {
        let dataArray = this.dataArray || [];
        let configArray = [];

        if (!this.dataArray) {
          dataArray = safeJsonParse(this.data, []);
          configArray = safeJsonParse(this.columnConfig, []);
        } else {
          if (this.autoColumns === 'true' && dataArray.length > 0) {
            const keys = Object.keys(dataArray[0]);
            configArray = keys.map(key => ({ [key]: key }));
          } else {
            configArray = safeJsonParse(this.columnConfig, []);
            if (configArray.length === 0 && dataArray.length > 0) {
              const keys = Object.keys(dataArray[0]);
              configArray = keys.map(key => ({ [key]: key }));
            }
          }
        }

        if (dataArray.length === 0) {
          return html`<div style="color: #999; padding: 8px;">No data</div>`;
        }

        return html`
          <table>
            <thead>
              <tr>
                ${configArray.map(col => {
          const key = Object.keys(col)[0];
          return html`<th>${col[key]}</th>`;
        })}
              </tr>
            </thead>
            <tbody>
              ${dataArray.map(row => html`
                <tr>
                  ${configArray.map(col => {
          const key = Object.keys(col)[0];
          return html`<td>${row[key]}</td>`;
        })}
                </tr>
              `)}
            </tbody>
          </table>
        `;
      }
    }

    // ============================================================================
    // MARKDOWN EDITOR
    // ============================================================================

    class MarkdownEditor extends LitElement {
      static properties = { value: { type: String } };
      static styles = css`
        :host { display: block; height: 100%; overflow: hidden; }
        #editor { height: 100%; overflow: auto; }
        .cm-editor { height: 100%; }
        .cm-scroller { overflow: auto; }
      `;

      constructor() {
        super();
        this.value = "";
        this.editorView = null;
      }

      firstUpdated() {
        const editorContainer = this.shadowRoot.getElementById("editor");
        const startState = EditorState.create({
          doc: this.value,
          extensions: [
            basicSetup,
            markdown(),
            EditorView.updateListener.of((update) => {
              if (update.docChanged) {
                this.value = update.state.doc.toString();
                this.dispatchEvent(
                  new CustomEvent("change", { detail: { value: this.value } })
                );
              }
            }),
          ],
        });

        this.editorView = new EditorView({
          state: startState,
          parent: editorContainer,
        });
      }

      render() {
        return html`<div id="editor"></div>`;
      }
    }

    // ============================================================================
    // MARKDOWN PREVIEW
    // ============================================================================

    class MarkdownPreview extends LitElement {
      static properties = {
        markdown: { type: String },
        processedHtml: { type: String }
      };
      static styles = css`
        :host {
          display: block;
          height: 100%;
          overflow: auto;
          padding: 20px;
          background: #fafafa;
        }
        .preview {
          max-width: 800px;
          margin: 0 auto;
          background: white;
          padding: 30px;
          border-radius: 4px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
      `;

      constructor() {
        super();
        this.markdown = "";
        this.processedHtml = "";
        this.unsubscribers = [];
        this._lastMarkdown = '';
        this._dataSubscriptions = new Set();
        this._needsRenderAfterLoad = false;
        this.setupMarkedExtension();
      }

      connectedCallback() {
        super.connectedCallback();

        // Listen for initial load completion FIRST
        initialLoadTracker.onComplete(() => {
          if (this._needsRenderAfterLoad) {
            console.log('[MarkdownPreview] Initial load complete, processing deferred updates');
            this._needsRenderAfterLoad = false;
            this.processMarkdown();
          }
        });

        // Then subscribe to data (which will happen after first processMarkdown in updated())
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.unsubscribers.forEach(unsub => unsub());
        this.unsubscribers = [];
      }

      subscribeToReferencedData() {
        const dataRefs = this.markdown.match(/\$\{data\.(\w+)\}/g);
        if (!dataRefs) return;

        const dataNames = [...new Set(dataRefs.map(ref => ref.match(/\$\{data\.(\w+)\}/)[1]))];

        dataNames.forEach(dataName => {
          // Only subscribe if not already subscribed
          if (!this._dataSubscriptions.has(dataName)) {
            console.log(`[MarkdownPreview] Subscribing to data.${dataName}`);
            const unsubscribe = storeManager.subscribe(`data.${dataName}`, () => {
              if (!initialLoadTracker.isLoadComplete()) {
                console.log(`[MarkdownPreview] data.${dataName} changed during initial load, deferring update`);
                this._needsRenderAfterLoad = true;
                return;
              }
              console.log(`[MarkdownPreview] data.${dataName} changed, re-processing markdown`);
              this.processMarkdown();
            });
            this.unsubscribers.push(unsubscribe);
            this._dataSubscriptions.add(dataName);
          }
        });
      }

      setupMarkedExtension() {
        marked.use({
          extensions: [{
            name: 'sqlCodeBlock',
            level: 'block',
            start(src) {
              return src.match(/^```sql/)?.index;
            },
            tokenizer(src) {
              const match = src.match(/^```sql([^\n]*)\n([\s\S]*?)```/);
              if (match) {
                const attrs = match[1].trim();
                const code = match[2];
                const nameMatch = attrs.match(/name=([^\s]+)/);
                const hideMatch = attrs.match(/hide=(true|false)/);
                const dependsOnMatch = attrs.match(/dependsOn=\[([^\]]+)\]/);

                return {
                  type: 'sqlCodeBlock',
                  raw: match[0],
                  code: code,
                  name: nameMatch ? nameMatch[1].replace(/['"]/g, '') : '',
                  hide: hideMatch ? hideMatch[1] === 'true' : false,
                  dependsOn: dependsOnMatch ? dependsOnMatch[1].split(',').map(s => s.trim()) : []
                };
              }
            },
            renderer(token) {
              return `<sql-code-block code='${token.code.replace(/'/g, "&#39;")}' name="${token.name}" ${token.hide ? 'hide' : ''} dependson='${JSON.stringify(token.dependsOn)}'></sql-code-block>`;
            }
          },
          {
            name: 'httpCodeBlock',
            level: 'block',
            start(src) {
              return src.match(/^```http/)?.index;
            },
            tokenizer(src) {
              const match = src.match(/^```http([^\n]*)\n([\s\S]*?)```/);
              if (match) {
                const attrs = match[1].trim();
                const code = match[2];
                const nameMatch = attrs.match(/name=([^\s]+)/);
                const hideMatch = attrs.match(/hide=(true|false)/);
                const insertMatch = attrs.match(/insert=(true|false)/);
                const onActionMatch = attrs.match(/onAction=([^\s]+)/);
                return {
                  type: 'httpCodeBlock',
                  raw: match[0],
                  code: code,
                  name: nameMatch ? nameMatch[1].replace(/['"]/g, '') : '',
                  hide: hideMatch ? hideMatch[1] === 'true' : false,
                  insert: insertMatch ? insertMatch[1] === 'true' : false,
                  onAction: onActionMatch ? onActionMatch[1].replace(/['"]/g, '') : ''
                };
              }
            },
            renderer(token) {
              return `<http-code-block code='${token.code.replace(/'/g, "&#39;")}' name="${token.name}" ${token.hide ? 'hide' : ''} ${token.insert ? 'insert' : ''} ${token.onAction ? `onaction="${token.onAction}"` : ''}></http-code-block>`;
            }
          }]
        });
      }

      updated(changedProperties) {
        if (changedProperties.has('markdown') && this.markdown !== this._lastMarkdown) {
          this._lastMarkdown = this.markdown;

          // Clear old subscriptions before setting up new ones
          this.unsubscribers.forEach(unsub => unsub());
          this.unsubscribers = [];
          this._dataSubscriptions.clear();

          // Process markdown first (this will create the HTML structure)
          this.processMarkdown();

          // Then subscribe to data changes for reactive updates
          this.subscribeToReferencedData();

          // If initial load is already complete and we need to render with data
          if (initialLoadTracker.isLoadComplete()) {
            console.log('[MarkdownPreview] Initial load already complete, processing markdown with data');
            // Small delay to ensure data is available
            setTimeout(() => this.processMarkdown(), 50);
          }
        }
      }

      processMarkdown() {
        const { data: frontmatter, content } = matter(this.markdown);

        Object.entries(frontmatter).forEach(([key, value]) => {
          storeManager.setState(`frontmatter.${key}`, value);
        });

        let htmlContent = marked.parse(content);

        // Replace data references with actual data from store
        htmlContent = htmlContent.replace(/\$\{data\.(\w+)\}/g, (match, queryName) => {
          const result = storeManager.getState(`data.${queryName}`);
          console.log(`[MarkdownPreview] Replacing ${match} with data:`, result ? `${result.length} items` : 'null');
          if (result) {
            return JSON.stringify(result).replace(/'/g, "&#39;");
          }
          return '[]';
        });

        htmlContent = htmlContent.replace(/\$\{frontmatter\.(\w+)\}/g, (match, varName) => {
          const result = storeManager.getState(`frontmatter.${varName}`);
          if (result !== undefined) {
            return typeof result === 'object' ? JSON.stringify(result) : String(result);
          }
          return '';
        });

        console.log('[MarkdownPreview] Setting processedHtml, will trigger re-render');
        this.processedHtml = htmlContent;
      }

      render() {
        return html`
          <div class="preview">
            ${this.processedHtml
            ? html`<div .innerHTML=${this.processedHtml}></div>`
            : html`<p style="color: #999;">Start typing markdown...</p>`}
          </div>
        `;
      }
    }

    // ============================================================================
    // APP ROOT
    // ============================================================================

    class AppRoot extends LitElement {
      static properties = { markdownText: { type: String } };
      static styles = css`
        :host { display: block; height: 100%; }
        .container {
          display: grid;
          grid-template-columns: 1fr 1fr;
          height: 100%;
          gap: 1px;
          background: #ddd;
        }
        .panel {
          background: white;
          overflow: hidden;
          display: flex;
          flex-direction: column;
        }
        .panel-header {
          padding: 12px 20px;
          background: #f5f5f5;
          border-bottom: 1px solid #ddd;
          font-weight: 600;
        }
        .panel-content {
          flex: 1;
          overflow: hidden;
        }
      `;

      constructor() {
        super();
        this.markdownText = `---
title: My Dashboard
author: John Doe
year: 2025
api_url: https://api.example.com/data
---

# Welcome to Markdown Preview

By \$\{frontmatter.author\} (\$\{frontmatter.year\})

## Features
- Live preview
- **Bold** and *italic* text
- Code snippets

\`\`\`javascript
const hello = "world";
console.log(hello);
\`\`\`

> This is a blockquote

### Lists
1. First item
2. Second item
3. Third item

### Data Table

<data-table
  data='[{"city":"Rio","pop":6748000},{"city":"SP","pop":12252000}]'
  columnConfig='[{"city":"City"},{"pop":"Population"}]'>
</data-table>

### Chart Example

<vegalite-chart
  spec='{"mark":"bar","encoding":{"x":{"field":"city","type":"nominal"},"y":{"field":"pop","type":"quantitative"}},"data":{"values":[{"city":"Rio","pop":6748000},{"city":"SP","pop":12252000},{"city":"BH","pop":2521564}]},"width":400,"height":200}'>
</vegalite-chart>

### SQL Query Example

\`\`\`sql name=sales_summary hide=false
SELECT
  'Product A' as product, 150000 as sales, 'Electronics' as category
UNION ALL
SELECT 'Product B', 120000, 'Electronics'
UNION ALL
SELECT 'Product C', 95000, 'Home'
UNION ALL
SELECT 'Product D', 200000, 'Electronics'
\`\`\`

### Using SQL Results in Components

<data-table
  data='\$\{data.sales_summary\}'
  columnConfig='[{"product":"Product"},{"sales":"Sales"},{"category":"Category"}]'>
</data-table>

<vegalite-chart
  spec='{"mark":"bar","encoding":{"x":{"field":"product","type":"nominal"},"y":{"field":"sales","type":"quantitative"}},"data":{"values":\$\{data.sales_summary\}},"width":400,"height":200}'>
</vegalite-chart>

### Interactive Filtering Example

\`\`\`sql name=product_list hide=true
SELECT DISTINCT product
FROM (
  SELECT 'Product A' as product
  UNION ALL SELECT 'Product B'
  UNION ALL SELECT 'Product C'
) t
ORDER BY product
\`\`\`

<dropdown-select
  data='\$\{data.product_list\}'
  name='product_selection'
  label='Select Products'>
</dropdown-select>

\`\`\`sql name=sales_data hide=true
WITH source_data AS (
  SELECT 'Product A' as product, 100 as sales, 'Q1' as quarter
  UNION ALL SELECT 'Product B', 150, 'Q1'
  UNION ALL SELECT 'Product C', 120, 'Q1'
  UNION ALL SELECT 'Product A', 130, 'Q2'
  UNION ALL SELECT 'Product B', 180, 'Q2'
  UNION ALL SELECT 'Product C', 140, 'Q2'
)
SELECT * FROM source_data
WHERE len(\$\{input.product_selection\}) = 0
   OR product IN (SELECT unnest(\$\{input.product_selection\}))
\`\`\`

<vegalite-chart
  spec='{"mark":"bar","encoding":{"x":{"field":"quarter","type":"nominal"},"y":{"field":"sales","type":"quantitative"},"color":{"field":"product","type":"nominal"}},"data":{"values":\$\{data.sales_data\}},"width":400,"height":200}'>
</vegalite-chart>

### GET HTTP Request Example

\`\`\`http name=todos hide=false insert=true
GET https://jsonplaceholder.typicode.com/todos/1 HTTP/1.1
\`\`\`

\`\`\`sql name=todo_response dependsOn=[todos]
SELECT * FROM todos
\`\`\`

### POST Request Example

\`\`\`http name=create_post hide=false
POST https://jsonplaceholder.typicode.com/posts HTTP/1.1
Content-Type: application/json

{
  "title": "My Post",
  "body": "This is the post content",
  "userId": 1
}
\`\`\`

### Interactive Form with Action Button

<text-input name="post_title" label="Post Title" placeholder="Enter the title of your post"></text-input>

<text-input name="post_body" label="Post Body" placeholder="Enter the content of your post"></text-input>

<action-button name="submit_post" label="Create Post"></action-button>

\`\`\`http name=user_post hide=false onAction=submit_post
POST https://jsonplaceholder.typicode.com/posts HTTP/1.1
Content-Type: application/json

{
  "title": "\$\{input.post_title\}",
  "body": "\$\{input.post_body\}",
  "userId": 1
}
\`\`\`
`;
      }

      connectedCallback() {
        super.connectedCallback();
        this._valueChangeHandler = (e) => {
          const { name, value } = e.detail || {};
          if (name) {
            storeManager.setState(`input.${name}`, value);
          }
        };

        this._actionTriggerHandler = (e) => {
          // Just pass through, components will handle their own action triggers
          console.log('[AppRoot] Action trigger event:', e.detail);
        };

        this.addEventListener('value-change', this._valueChangeHandler);
        this.addEventListener('action-trigger', this._actionTriggerHandler);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._valueChangeHandler) {
          this.removeEventListener('value-change', this._valueChangeHandler);
        }
        if (this._actionTriggerHandler) {
          this.removeEventListener('action-trigger', this._actionTriggerHandler);
        }
      }

      handleEditorChange(e) {
        this.markdownText = e.detail.value;
      }

      render() {
        return html`
          <div class="container">
            <div class="panel">
              <div class="panel-header">Markdown Editor</div>
              <div class="panel-content">
                <markdown-editor .value=${this.markdownText} @change=${this.handleEditorChange}></markdown-editor>
              </div>
            </div>
            <div class="panel">
              <div class="panel-header">Preview</div>
              <div class="panel-content">
                <markdown-preview .markdown=${this.markdownText}></markdown-preview>
              </div>
            </div>
          </div>
        `;
      }
    }

    // ============================================================================
    // REGISTER CUSTOM ELEMENTS
    // ============================================================================

    customElements.define("text-input", TextInput);
    customElements.define("action-button", ActionButton);
    customElements.define("dropdown-select", DropdownSelect);
    customElements.define("sql-code-block", SqlCodeBlock);
    customElements.define("http-code-block", HttpCodeBlock);
    customElements.define("vegalite-chart", VegaLiteChart);
    customElements.define("data-table", DataTable);
    customElements.define("markdown-editor", MarkdownEditor);
    customElements.define("markdown-preview", MarkdownPreview);
    customElements.define("app-root", AppRoot);

    document.getElementById("root").appendChild(document.createElement("app-root"));
  </script>
</body>

</html>