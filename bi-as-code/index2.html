<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Markdown Preview</title>

  <script type="importmap">
    {
      "imports": {
        "lit": "https://esm.sh/lit@3.1.0",
        "lit/": "https://esm.sh/lit@3.1.0/",
        "codemirror": "https://esm.sh/*codemirror@6.0.1",
        "@codemirror/": "https://esm.sh/*@codemirror/",
        "@lezer/": "https://esm.sh/*@lezer/",
        "style-mod": "https://esm.sh/style-mod",
        "w3c-keyname": "https://esm.sh/w3c-keyname",
        "crelt": "https://esm.sh/crelt",
        "@marijn/find-cluster-break": "https://esm.sh/@marijn/find-cluster-break",
        "marked": "https://esm.sh/marked@16.0.0",
        "vega": "https://esm.sh/vega@5.22.1",
        "vega-lite": "https://esm.sh/vega-lite@5.6.0",
        "vega-embed": "https://esm.sh/vega-embed@6.21.0",
        "@duckdb/duckdb-wasm": "https://esm.sh/@duckdb/duckdb-wasm@1.30.0"
      }
    }
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      height: 100vh;
      overflow: hidden;
    }

    #root {
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="module">
    import { LitElement, html, css } from "lit";
    import { basicSetup, EditorView } from "codemirror";
    import { EditorState } from "@codemirror/state";
    import { markdown } from "@codemirror/lang-markdown";
    import { marked } from "marked";
    import vegaEmbed from "vega-embed";
    import * as duckdb from '@duckdb/duckdb-wasm';

    // Global DuckDB instance
    let dbInstance = null;
    let dbConnection = null;

    async function initDuckDB() {
      if (dbInstance) return dbInstance;

      const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
      const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
      const worker_url = URL.createObjectURL(
        new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
      );
      const worker = new Worker(worker_url);
      const logger = new duckdb.ConsoleLogger();
      const db = new duckdb.AsyncDuckDB(logger, worker);
      await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
      URL.revokeObjectURL(worker_url);

      dbInstance = db;
      dbConnection = await db.connect();
      return db;
    }

    class SqlCodeBlock extends LitElement {
      static properties = {
        code: { type: String },
        name: { type: String },
        hide: { type: Boolean },
        result: { type: Array }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        .code-block {
          background: #f5f5f5;
          padding: 12px;
          border-radius: 4px;
          overflow-x: auto;
          margin-bottom: 12px;
        }
        .code-block.hidden { display: none; }
        pre {
          margin: 0;
          font-family: monospace;
          font-size: 14px;
        }
        .header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
          font-size: 12px;
          color: #666;
        }
        .status {
          padding: 4px 8px;
          border-radius: 3px;
          font-size: 11px;
        }
        .loading { background: #fff3cd; }
        .success { background: #d4edda; }
        .error { background: #f8d7da; color: #721c24; }
      `;

      constructor() {
        super();
        this.code = '';
        this.name = '';
        this.hide = false;
        this.result = null;
        this.status = 'loading';
        this.error = null;
      }

      async connectedCallback() {
        super.connectedCallback();
        await this.executeQuery();
      }

      async executeQuery() {
        try {
          await initDuckDB();
          const queryResult = await dbConnection.query(this.code);
          this.result = queryResult.toArray().map(row => row.toJSON());
          this.status = 'success';
        } catch (e) {
          this.error = e.message;
          this.status = 'error';
          console.error('SQL execution error:', e);
        }
        this.requestUpdate();
      }

      renderTable() {
        if (!this.result || this.result.length === 0) return '';

        const keys = Object.keys(this.result[0]);

        return html`
          <table style="width: 100%; border-collapse: collapse; margin-top: 12px;">
            <thead>
              <tr>
                ${keys.map(key => html`<th style="padding: 8px; text-align: left; border: 1px solid #ddd; background: #f5f5f5; font-weight: 600;">${key}</th>`)}
              </tr>
            </thead>
            <tbody>
              ${this.result.map(row => html`
                <tr>
                  ${keys.map(key => html`<td style="padding: 8px; text-align: left; border: 1px solid #ddd;">${row[key]}</td>`)}
                </tr>
              `)}
            </tbody>
          </table>
        `;
      }

      render() {
        return html`
          <div>
            ${this.name ? html`
              <div class="header">
                <strong>${this.name}</strong>
                <span class="status ${this.status}">
                  ${this.status === 'loading' ? 'Executing...' :
              this.status === 'success' ? `${this.result?.length || 0} rows` :
                'Error'}
                </span>
              </div>
            ` : ''}
            <div class="code-block ${this.hide ? 'hidden' : ''}">
              <pre><code>${this.code}</code></pre>
            </div>
            ${this.status === 'error' ? html`
              <div class="error" style="padding: 8px; margin-top: 8px;">
                ${this.error}
              </div>
            ` : ''}
            ${this.status === 'success' && this.result && this.result.length > 0 ? this.renderTable() : ''}
          </div>
        `;
      }
    }

    class VegaLiteChart extends LitElement {
      static properties = {
        spec: { type: String }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        #chart { width: 100%; }
        .empty { color: #999; padding: 12px; }
        .error { color: #c33; padding: 8px; }
      `;

      constructor() {
        super();
        this.spec = null;
      }

      updated(changedProperties) {
        if (changedProperties.has("spec")) {
          this.renderChart();
        }
      }

      async renderChart() {
        const chartDiv = this.renderRoot.querySelector("#chart");
        if (!chartDiv) return;

        if (!this.spec) {
          chartDiv.innerHTML = '<div class="empty">No chart spec provided</div>';
          return;
        }

        let specObj;
        try {
          specObj = JSON.parse(this.spec);
        } catch (e) {
          chartDiv.innerHTML = '<div class="error">Invalid spec JSON</div>';
          return;
        }

        try {
          await vegaEmbed(chartDiv, specObj, { actions: false });
        } catch (e) {
          console.error("vegaEmbed error:", e);
          chartDiv.innerHTML = '<div class="error">Chart render error</div>';
        }
      }

      render() {
        return html`<div id="chart"></div>`;
      }
    }

    class DataTable extends LitElement {
      static properties = {
        data: { type: String },
        columnConfig: { type: String },
        dataArray: { type: Array },
        autoColumns: { type: String }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        table {
          width: 100%;
          border-collapse: collapse;
        }
        th, td {
          padding: 8px;
          text-align: left;
          border: 1px solid #ddd;
        }
        th {
          background: #f5f5f5;
          font-weight: 600;
        }
      `;

      constructor() {
        super();
        this.data = '[]';
        this.columnConfig = '[]';
        this.dataArray = null;
        this.autoColumns = 'false';
      }

      render() {
        let dataArray = this.dataArray || [];
        let configArray = [];

        if (!this.dataArray) {
          try {
            dataArray = JSON.parse(this.data);
            configArray = JSON.parse(this.columnConfig);
          } catch (e) {
            return html`<div>Error parsing data</div>`;
          }
        } else {
          // Auto-generate columns from data
          if (this.autoColumns === 'true' && dataArray.length > 0) {
            const keys = Object.keys(dataArray[0]);
            configArray = keys.map(key => ({ [key]: key }));
          } else {
            try {
              configArray = JSON.parse(this.columnConfig);
            } catch (e) {
              if (dataArray.length > 0) {
                const keys = Object.keys(dataArray[0]);
                configArray = keys.map(key => ({ [key]: key }));
              }
            }
          }
        }

        if (dataArray.length === 0) {
          return html`<div style="color: #999; padding: 8px;">No data</div>`;
        }

        return html`
          <table>
            <thead>
              <tr>
                ${configArray.map(col => {
          const key = Object.keys(col)[0];
          return html`<th>${col[key]}</th>`;
        })}
              </tr>
            </thead>
            <tbody>
              ${dataArray.map(row => html`
                <tr>
                  ${configArray.map(col => {
          const key = Object.keys(col)[0];
          return html`<td>${row[key]}</td>`;
        })}
                </tr>
              `)}
            </tbody>
          </table>
        `;
      }
    }

    class MarkdownEditor extends LitElement {
      static properties = { value: { type: String } };
      static styles = css`
        :host { display: block; height: 100%; overflow: hidden; }
        #editor { height: 100%; overflow: auto; }
        .cm-editor { height: 100%; }
        .cm-scroller { overflow: auto; }
      `;

      constructor() {
        super();
        this.value = "";
        this.editorView = null;
      }

      firstUpdated() {
        const editorContainer = this.shadowRoot.getElementById("editor");
        const startState = EditorState.create({
          doc: this.value,
          extensions: [
            basicSetup,
            markdown(),
            EditorView.updateListener.of((update) => {
              if (update.docChanged) {
                this.value = update.state.doc.toString();
                this.dispatchEvent(
                  new CustomEvent("change", { detail: { value: this.value } })
                );
              }
            }),
          ],
        });

        this.editorView = new EditorView({
          state: startState,
          parent: editorContainer,
        });
      }

      render() {
        return html`<div id="editor"></div>`;
      }
    }

    class MarkdownPreview extends LitElement {
      static properties = { markdown: { type: String } };
      static styles = css`
        :host {
          display: block;
          height: 100%;
          overflow: auto;
          padding: 20px;
          background: #fafafa;
        }
        .preview {
          max-width: 800px;
          margin: 0 auto;
          background: white;
          padding: 30px;
          border-radius: 4px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
      `;

      constructor() {
        super();
        this.markdown = "";
        this.setupMarkedExtension();
      }

      setupMarkedExtension() {
        marked.use({
          extensions: [{
            name: 'sqlCodeBlock',
            level: 'block',
            start(src) {
              return src.match(/^```sql/)?.index;
            },
            tokenizer(src) {
              const match = src.match(/^```sql([^\n]*)\n([\s\S]*?)```/);
              if (match) {
                const attrs = match[1].trim();
                const code = match[2];
                const nameMatch = attrs.match(/name=([^\s]+)/);
                const hideMatch = attrs.match(/hide=(true|false)/);

                return {
                  type: 'sqlCodeBlock',
                  raw: match[0],
                  code: code,
                  name: nameMatch ? nameMatch[1] : '',
                  hide: hideMatch ? hideMatch[1] === 'true' : false
                };
              }
            },
            renderer(token) {
              return `<sql-code-block code='${token.code.replace(/'/g, "&#39;")}' name="${token.name}" ${token.hide ? 'hide' : ''}></sql-code-block>`;
            }
          }]
        });
      }

      render() {
        const htmlContent = marked.parse(this.markdown);
        return html`
          <div class="preview">
            ${htmlContent
            ? html`<div .innerHTML=${htmlContent}></div>`
            : html`<p style="color: #999;">Start typing markdown...</p>`}
          </div>
        `;
      }
    }

    class AppRoot extends LitElement {
      static properties = { markdownText: { type: String } };
      static styles = css`
        :host { display: block; height: 100%; }
        .container {
          display: grid;
          grid-template-columns: 1fr 1fr;
          height: 100%;
          gap: 1px;
          background: #ddd;
        }
        .panel {
          background: white;
          overflow: hidden;
          display: flex;
          flex-direction: column;
        }
        .panel-header {
          padding: 12px 20px;
          background: #f5f5f5;
          border-bottom: 1px solid #ddd;
          font-weight: 600;
        }
        .panel-content {
          flex: 1;
          overflow: hidden;
        }
      `;

      constructor() {
        super();
        this.markdownText = `# Welcome to Markdown Preview

## Features
- Live preview
- **Bold** and *italic* text
- Code snippets

\`\`\`javascript
const hello = "world";
console.log(hello);
\`\`\`

> This is a blockquote

### Lists
1. First item
2. Second item
3. Third item

### Data Table

<data-table
  data='[{"city":"Rio","pop":6748000},{"city":"SP","pop":12252000}]'
  columnConfig='[{"city":"City"},{"pop":"Population"}]'>
</data-table>

### Chart Example

<vegalite-chart
  spec='{"mark":"bar","encoding":{"x":{"field":"city","type":"nominal"},"y":{"field":"pop","type":"quantitative"}},"data":{"values":[{"city":"Rio","pop":6748000},{"city":"SP","pop":12252000},{"city":"BH","pop":2521564}]},"width":400,"height":200}'>
</vegalite-chart>

### SQL Query Example

\`\`\`sql name=sales_summary hide=false
SELECT
  'Product A' as product, 150000 as sales, 'Electronics' as category
UNION ALL
SELECT 'Product B', 120000, 'Electronics'
UNION ALL
SELECT 'Product C', 95000, 'Home'
UNION ALL
SELECT 'Product D', 200000, 'Electronics'
\`\`\`
`;
      }

      handleEditorChange(e) {
        this.markdownText = e.detail.value;
      }

      render() {
        return html`
          <div class="container">
            <div class="panel">
              <div class="panel-header">Markdown Editor</div>
              <div class="panel-content">
                <markdown-editor .value=${this.markdownText} @change=${this.handleEditorChange}></markdown-editor>
              </div>
            </div>
            <div class="panel">
              <div class="panel-header">Preview</div>
              <div class="panel-content">
                <markdown-preview .markdown=${this.markdownText}></markdown-preview>
              </div>
            </div>
          </div>
        `;
      }
    }

    customElements.define("sql-code-block", SqlCodeBlock);
    customElements.define("vegalite-chart", VegaLiteChart);
    customElements.define("data-table", DataTable);
    customElements.define("markdown-editor", MarkdownEditor);
    customElements.define("markdown-preview", MarkdownPreview);
    customElements.define("app-root", AppRoot);

    document.getElementById("root").appendChild(document.createElement("app-root"));
  </script>
</body>

</html>