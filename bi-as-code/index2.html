<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Markdown Preview</title>

  <script type="importmap">
    {
      "imports": {
        "lit": "https://esm.sh/lit@3.1.0",
        "lit/": "https://esm.sh/lit@3.1.0/",
        "codemirror": "https://esm.sh/*codemirror@6.0.1",
        "@codemirror/": "https://esm.sh/*@codemirror/",
        "@lezer/": "https://esm.sh/*@lezer/",
        "style-mod": "https://esm.sh/style-mod",
        "w3c-keyname": "https://esm.sh/w3c-keyname",
        "crelt": "https://esm.sh/crelt",
        "@marijn/find-cluster-break": "https://esm.sh/@marijn/find-cluster-break",
        "marked": "https://esm.sh/marked@16.0.0",
        "vega": "https://cdn.jsdelivr.net/npm/vega@6.2.0/+esm",
        "vega-lite": "https://cdn.jsdelivr.net/npm/vega-lite@6.4.1/+esm",
        "vega-embed": "https://cdn.jsdelivr.net/npm/vega-embed@7.1.0/+esm",
        "@duckdb/duckdb-wasm": "https://esm.sh/@duckdb/duckdb-wasm@1.30.0"
      }
    }
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      height: 100vh;
      overflow: hidden;
    }

    #root {
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="module">
    import { LitElement, html, css } from "lit";
    import { basicSetup, EditorView } from "codemirror";
    import { EditorState } from "@codemirror/state";
    import { markdown } from "@codemirror/lang-markdown";
    import { marked } from "marked";
    import vegaEmbed from "vega-embed";
    import * as duckdb from '@duckdb/duckdb-wasm';

    // Global Store with Observable Pattern
    const store = {
      data: {},
      input: {}
    };

    const storeManager = {
      listeners: new Map(),

      setState(path, value) {
        const [category, key] = path.split('.');
        if (category === 'data' || category === 'input') {
          store[category][key] = value;
          console.log(`[store] setState(${path}):`, value);
          this.notify(path, value);
        }
      },

      getState(path) {
        const [category, key] = path.split('.');
        return store[category]?.[key];
      },

      subscribe(path, callback) {
        if (!this.listeners.has(path)) {
          this.listeners.set(path, new Set());
        }
        this.listeners.get(path).add(callback);

        return () => {
          const callbacks = this.listeners.get(path);
          if (callbacks) {
            callbacks.delete(callback);
            if (callbacks.size === 0) {
              this.listeners.delete(path);
            }
          }
        };
      },

      notify(path, value) {
        console.log(`[store] notify(${path}) - ${this.listeners.get(path)?.size || 0} listeners`);
        const callbacks = this.listeners.get(path);
        if (callbacks) {
          callbacks.forEach(cb => cb(value));
        }

        // Notify wildcard listeners
        const [category] = path.split('.');
        const wildcardPath = `${category}.*`;
        const wildcardCallbacks = this.listeners.get(wildcardPath);
        if (wildcardCallbacks) {
          console.log(`[store] notify wildcard(${wildcardPath}) - ${wildcardCallbacks.size} listeners`);
          wildcardCallbacks.forEach(cb => cb(value, path));
        }

        // Dispatch global event
        window.dispatchEvent(new CustomEvent('store-updated', {
          detail: { path, value }
        }));
      }
    };

    // Global DuckDB instance
    let dbInstance = null;
    let dbConnection = null;

    async function initDuckDB() {
      if (dbInstance) return dbInstance;

      const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
      const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
      const worker_url = URL.createObjectURL(
        new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
      );
      const worker = new Worker(worker_url);
      const logger = new duckdb.ConsoleLogger();
      const db = new duckdb.AsyncDuckDB(logger, worker);
      await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
      URL.revokeObjectURL(worker_url);

      dbInstance = db;
      dbConnection = await db.connect();
      return db;
    }

    // Debounce utility
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    class DropdownSelect extends LitElement {
      static properties = {
        data: { type: String },
        name: { type: String },
        label: { type: String },
        multiple: { type: Boolean },
        selected: { type: Array }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        .select-container {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        label {
          font-weight: 600;
          font-size: 14px;
        }
        select {
          padding: 8px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
          background: white;
          min-height: 40px;
        }
        select[multiple] {
          min-height: 120px;
        }
      `;

      constructor() {
        super();
        this.data = '[]';
        this.name = '';
        this.label = '';
        this.multiple = true;
        this.selected = [];
      }

      connectedCallback() {
        super.connectedCallback();
        // Removed direct coupling to storeManager here so component is standalone.
        // If parent / app wants to initialize the select from store, it should set `selected` attribute or listen and set.
      }

      handleChange(e) {
        const selectElement = e.target;
        if (this.multiple) {
          this.selected = Array.from(selectElement.selectedOptions).map(opt => opt.value);
        } else {
          this.selected = [selectElement.value];
        }

        console.log(`[dropdown-select:${this.name}] Selection changed:`, this.selected);

        // Dispatch a neutral event instead of touching the global store.
        this.dispatchEvent(new CustomEvent('value-change', {
          detail: {
            name: this.name,
            value: this.selected
          },
          bubbles: true,
          composed: true
        }));
      }

      render() {
        let options = [];
        try {
          options = JSON.parse(this.data);
        } catch (e) {
          console.error('Invalid data JSON:', e);
        }

        const values = options.map(opt => {
          if (typeof opt === 'string') return opt;
          return Object.values(opt)[0];
        });

        return html`
          <div class="select-container">
            ${this.label ? html`<label>${this.label}</label>` : ''}
            <select
              ?multiple=${this.multiple}
              @change=${this.handleChange}>
              ${values.map(val => html`
                <option value=${val} ?selected=${this.selected.includes(val)}>
                  ${val}
                </option>
              `)}
            </select>
          </div>
        `;
      }
    }

    class SqlCodeBlock extends LitElement {
      static properties = {
        code: { type: String },
        name: { type: String },
        hide: { type: Boolean },
        result: { type: Array }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        .code-block {
          background: #f5f5f5;
          padding: 12px;
          border-radius: 4px;
          overflow-x: auto;
          margin-bottom: 12px;
        }
        pre {
          margin: 0;
          font-family: monospace;
          font-size: 14px;
        }
        .header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
          font-size: 12px;
          color: #666;
        }
        .status {
          padding: 4px 8px;
          border-radius: 3px;
          font-size: 11px;
        }
        .loading { background: #fff3cd; }
        .success { background: #d4edda; }
        .error { background: #f8d7da; color: #721c24; }
      `;

      constructor() {
        super();
        this.code = '';
        this.name = '';
        this.hide = false;
        this.result = null;
        this.status = 'loading';
        this.error = null;
        this.unsubscribers = [];
        this.debouncedExecute = debounce(() => this.executeQuery(), 300);
      }

      connectedCallback() {
        super.connectedCallback();

        // Find all ${input.xxx} references in the code
        const inputRefs = this.code.match(/\$\{input\.(\w+)\}/g);
        if (inputRefs) {
          const inputNames = [...new Set(inputRefs.map(ref => ref.match(/\$\{input\.(\w+)\}/)[1]))];
          console.log(`[${this.name}] Subscribing to inputs:`, inputNames);
          inputNames.forEach(inputName => {
            const unsubscribe = storeManager.subscribe(`input.${inputName}`, () => {
              console.log(`[${this.name}] Input ${inputName} changed, re-executing query`);
              this.debouncedExecute();
            });
            this.unsubscribers.push(unsubscribe);
          });
        }

        this.executeQuery();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.unsubscribers.forEach(unsub => unsub());
        this.unsubscribers = [];
      }

      async executeQuery() {
        try {
          await initDuckDB();

          let processedCode = this.code.replace(/\$\{input\.(\w+)\}/g, (match, inputName) => {
            const value = storeManager.getState(`input.${inputName}`);
            if (!value || (Array.isArray(value) && value.length === 0)) {
              return '[]';
            }
            // convert JS array ["A","B"] → DuckDB list ['A','B']
            return `['${value.join("','")}']`;
          });

          console.log(`[${this.name}] Executing query with processed code:`, processedCode);

          const queryResult = await dbConnection.query(processedCode);
          this.result = queryResult.toArray().map(row => row.toJSON());
          this.status = 'success';

          if (this.name) {
            console.log(`[${this.name}] Storing ${this.result.length} rows in store`);
            storeManager.setState(`data.${this.name}`, this.result);
          }
        } catch (e) {
          this.error = e.message;
          this.status = 'error';
          console.error('SQL execution error:', e);
        }
        this.requestUpdate();
      }

      renderTable() {
        if (!this.result || this.result.length === 0) return '';

        const keys = Object.keys(this.result[0]);

        return html`
          <details open style="margin-top: 12px;">
            <summary style="cursor: pointer; padding: 8px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-weight: 600;">
              Query Results (${this.result.length} rows)
            </summary>
            <table style="width: 100%; border-collapse: collapse; margin-top: 8px;">
              <thead>
                <tr>
                  ${keys.map(key => html`<th style="padding: 8px; text-align: left; border: 1px solid #ddd; background: #f5f5f5; font-weight: 600;">${key}</th>`)}
                </tr>
              </thead>
              <tbody>
                ${this.result.map(row => html`
                  <tr>
                    ${keys.map(key => html`<td style="padding: 8px; text-align: left; border: 1px solid #ddd;">${row[key]}</td>`)}
                  </tr>
                `)}
              </tbody>
            </table>
          </details>
        `;
      }

      render() {
        if (this.hide) {
          return html``;
        }

        return html`
          <div>
            ${this.name ? html`
              <div class="header">
                <strong>${this.name}</strong>
                <span class="status ${this.status}">
                  ${this.status === 'loading' ? 'Executing...' :
              this.status === 'success' ? `${this.result?.length || 0} rows` :
                'Error'}
                </span>
              </div>
            ` : ''}
            <div class="code-block">
              <pre><code>${this.code}</code></pre>
            </div>
            ${this.status === 'error' ? html`
              <div class="error" style="padding: 8px; margin-top: 8px;">
                ${this.error}
              </div>
            ` : ''}
            ${this.status === 'success' && this.result && this.result.length > 0 ? this.renderTable() : ''}
          </div>
        `;
      }
    }

    class VegaLiteChart extends LitElement {
      static properties = {
        spec: { type: String }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        #chart { width: 100%; }
        .empty { color: #999; padding: 12px; }
        .error { color: #c33; padding: 8px; }
      `;

      constructor() {
        super();
        this.spec = null;
      }

      updated(changedProperties) {
        if (changedProperties.has("spec")) {
          this.renderChart();
        }
      }

      async renderChart() {
        const chartDiv = this.renderRoot.querySelector("#chart");
        if (!chartDiv) return;

        if (!this.spec) {
          chartDiv.innerHTML = '<div class="empty">No chart spec provided</div>';
          return;
        }

        let specObj;
        try {
          specObj = JSON.parse(this.spec);
        } catch (e) {
          chartDiv.innerHTML = '<div class="error">Invalid spec JSON</div>';
          return;
        }

        try {
          await vegaEmbed(chartDiv, specObj, { actions: false });
        } catch (e) {
          console.error("vegaEmbed error:", e);
          chartDiv.innerHTML = '<div class="error">Chart render error</div>';
        }
      }

      render() {
        return html`<div id="chart"></div>`;
      }
    }

    class DataTable extends LitElement {
      static properties = {
        data: { type: String },
        columnConfig: { type: String },
        dataArray: { type: Array },
        autoColumns: { type: String }
      };

      static styles = css`
        :host { display: block; margin: 20px 0; }
        table {
          width: 100%;
          border-collapse: collapse;
        }
        th, td {
          padding: 8px;
          text-align: left;
          border: 1px solid #ddd;
        }
        th {
          background: #f5f5f5;
          font-weight: 600;
        }
      `;

      constructor() {
        super();
        this.data = '[]';
        this.columnConfig = '[]';
        this.dataArray = null;
        this.autoColumns = 'false';
      }

      render() {
        let dataArray = this.dataArray || [];
        let configArray = [];

        if (!this.dataArray) {
          try {
            dataArray = JSON.parse(this.data);
            configArray = JSON.parse(this.columnConfig);
          } catch (e) {
            return html`<div>Error parsing data</div>`;
          }
        } else {
          if (this.autoColumns === 'true' && dataArray.length > 0) {
            const keys = Object.keys(dataArray[0]);
            configArray = keys.map(key => ({ [key]: key }));
          } else {
            try {
              configArray = JSON.parse(this.columnConfig);
            } catch (e) {
              if (dataArray.length > 0) {
                const keys = Object.keys(dataArray[0]);
                configArray = keys.map(key => ({ [key]: key }));
              }
            }
          }
        }

        if (dataArray.length === 0) {
          return html`<div style="color: #999; padding: 8px;">No data</div>`;
        }

        return html`
          <table>
            <thead>
              <tr>
                ${configArray.map(col => {
          const key = Object.keys(col)[0];
          return html`<th>${col[key]}</th>`;
        })}
              </tr>
            </thead>
            <tbody>
              ${dataArray.map(row => html`
                <tr>
                  ${configArray.map(col => {
          const key = Object.keys(col)[0];
          return html`<td>${row[key]}</td>`;
        })}
                </tr>
              `)}
            </tbody>
          </table>
        `;
      }
    }

    class MarkdownEditor extends LitElement {
      static properties = { value: { type: String } };
      static styles = css`
        :host { display: block; height: 100%; overflow: hidden; }
        #editor { height: 100%; overflow: auto; }
        .cm-editor { height: 100%; }
        .cm-scroller { overflow: auto; }
      `;

      constructor() {
        super();
        this.value = "";
        this.editorView = null;
      }

      firstUpdated() {
        const editorContainer = this.shadowRoot.getElementById("editor");
        const startState = EditorState.create({
          doc: this.value,
          extensions: [
            basicSetup,
            markdown(),
            EditorView.updateListener.of((update) => {
              if (update.docChanged) {
                this.value = update.state.doc.toString();
                this.dispatchEvent(
                  new CustomEvent("change", { detail: { value: this.value } })
                );
              }
            }),
          ],
        });

        this.editorView = new EditorView({
          state: startState,
          parent: editorContainer,
        });
      }

      render() {
        return html`<div id="editor"></div>`;
      }
    }

    class HttpCodeBlock extends LitElement {
      static properties = {
        code: { type: String },
        name: { type: String },
        hide: { type: Boolean },
        result: { type: Object }
      };

      static styles = css`
    :host { display: block; margin: 20px 0; }
    .code-block {
      background: #f5f5f5;
      padding: 12px;
      border-radius: 4px;
      overflow-x: auto;
      margin-bottom: 12px;
    }
    pre { margin: 0; font-family: monospace; font-size: 14px; }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 12px;
      color: #666;
    }
    .status { padding: 4px 8px; border-radius: 3px; font-size: 11px; }
    .loading { background: #fff3cd; }
    .success { background: #d4edda; }
    .error { background: #f8d7da; color: #721c24; }
    .json-result {
      background: #282c34;
      color: #abb2bf;
      padding: 16px;
      border-radius: 4px;
      overflow-x: auto;
      margin-top: 12px;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    .json-key { color: #e06c75; }
    .json-string { color: #98c379; }
    .json-number { color: #d19a66; }
    .json-boolean { color: #56b6c2; }
    .json-null { color: #c678dd; }
  `;

      constructor() {
        super();
        this.code = '';
        this.name = '';
        this.hide = false;
        this.result = null;
        this.status = 'loading';
        this.error = null;
        this.responseStatus = null;
      }

      connectedCallback() {
        super.connectedCallback();
        this.executeRequest();
      }

      parseHttpRequest() {
        const lines = this.code.trim().split('\n');
        let requestLine = '';
        const headers = {};
        let body = null;
        let inBody = false;

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          if (!line && !inBody && requestLine) {
            inBody = true;
            continue;
          }

          if (!requestLine && line.match(/^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)/i)) {
            requestLine = line;
          } else if (!inBody && line.includes(':')) {
            const [key, ...valueParts] = line.split(':');
            headers[key.trim()] = valueParts.join(':').trim();
          } else if (inBody && line) {
            if (body === null) body = '';
            body += line + '\n';
          }
        }

        const requestMatch = requestLine.match(/^(\w+)\s+(.+?)(?:\s+HTTP\/[\d.]+)?$/i);
        if (!requestMatch) throw new Error('Invalid request line format');

        const [, method, url] = requestMatch;
        return {
          method: method.toUpperCase(),
          url: url.trim(),
          headers,
          body: body ? body.trim() : null
        };
      }

      async executeRequest() {
        try {
          const { method, url, headers, body } = this.parseHttpRequest();
          const fetchOptions = { method, headers: {} };

          Object.entries(headers).forEach(([key, value]) => {
            fetchOptions.headers[key] = value;
          });

          if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
            fetchOptions.body = body;
          }

          console.log(`[${this.name || 'http'}] Executing ${method} ${url}`);

          const response = await fetch(url, fetchOptions);
          this.responseStatus = response.status;

          const contentType = response.headers.get('content-type');
          let data;

          if (contentType && contentType.includes('application/json')) {
            data = await response.json();
          } else {
            data = await response.text();
          }

          this.result = data;
          this.status = response.ok ? 'success' : 'error';

          if (this.name) {
            console.log(`[${this.name}] Storing response in store`);
            storeManager.setState(`data.${this.name}`, this.result);
          }
        } catch (e) {
          this.error = e.message;
          this.status = 'error';
          console.error('HTTP execution error:', e);
        }
        this.requestUpdate();
      }

      syntaxHighlightJson(json) {
        if (typeof json !== 'string') json = JSON.stringify(json, null, 2);
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match) => {
          let cls = 'json-number';
          if (/^"/.test(match)) {
            cls = /:$/.test(match) ? 'json-key' : 'json-string';
          } else if (/true|false/.test(match)) {
            cls = 'json-boolean';
          } else if (/null/.test(match)) {
            cls = 'json-null';
          }
          return `<span class="${cls}">${match}</span>`;
        });
      }

      render() {
        if (this.hide) return html``;
        return html`
      <div>
        ${this.name ? html`
          <div class="header">
            <strong>${this.name}</strong>
            <span class="status ${this.status}">
              ${this.status === 'loading' ? 'Executing...' :
              this.status === 'success' ? `HTTP ${this.responseStatus}` : 'Error'}
            </span>
          </div>
        ` : ''}
        <div class="code-block"><pre><code>${this.code}</code></pre></div>
        ${this.status === 'error' ? html`
          <div class="error" style="padding: 8px; margin-top: 8px;">${this.error}</div>
        ` : ''}
        ${this.status === 'success' && this.result ? html`
          <details open>
            <summary style="cursor: pointer; padding: 8px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-weight: 600; margin-bottom: 8px;">
              Response (HTTP ${this.responseStatus})
            </summary>
            <div class="json-result">
              <pre .innerHTML=${this.syntaxHighlightJson(this.result)}></pre>
            </div>
          </details>
        ` : ''}
      </div>
    `;
      }
    }

    class MarkdownPreview extends LitElement {
      static properties = {
        markdown: { type: String },
        processedHtml: { type: String }
      };
      static styles = css`
        :host {
          display: block;
          height: 100%;
          overflow: auto;
          padding: 20px;
          background: #fafafa;
        }
        .preview {
          max-width: 800px;
          margin: 0 auto;
          background: white;
          padding: 30px;
          border-radius: 4px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
      `;

      constructor() {
        super();
        this.markdown = "";
        this.processedHtml = "";
        this.unsubscriber = null;
        this.setupMarkedExtension();
      }

      connectedCallback() {
        super.connectedCallback();

        // Subscribe to all store changes
        this.unsubscriber = storeManager.subscribe('data.*', () => {
          this.processMarkdown();
        });
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this.unsubscriber) {
          this.unsubscriber();
        }
      }

      setupMarkedExtension() {
        marked.use({
          extensions: [{
            name: 'sqlCodeBlock',
            level: 'block',
            start(src) {
              return src.match(/^```sql/)?.index;
            },
            tokenizer(src) {
              const match = src.match(/^```sql([^\n]*)\n([\s\S]*?)```/);
              if (match) {
                const attrs = match[1].trim();
                const code = match[2];
                const nameMatch = attrs.match(/name=([^\s]+)/);
                const hideMatch = attrs.match(/hide=(true|false)/);

                return {
                  type: 'sqlCodeBlock',
                  raw: match[0],
                  code: code,
                  name: nameMatch ? nameMatch[1].replace(/['"]/g, '') : '',
                  hide: hideMatch ? hideMatch[1] === 'true' : false
                };
              }
            },
            renderer(token) {
              return `<sql-code-block code='${token.code.replace(/'/g, "&#39;")}' name="${token.name}" ${token.hide ? 'hide' : ''}></sql-code-block>`;
            }
          },
          {
            name: 'httpCodeBlock',
            level: 'block',
            start(src) {
              return src.match(/^```http/)?.index;
            },
            tokenizer(src) {
              const match = src.match(/^```http([^\n]*)\n([\s\S]*?)```/);
              if (match) {
                const attrs = match[1].trim();
                const code = match[2];
                const nameMatch = attrs.match(/name=([^\s]+)/);
                const hideMatch = attrs.match(/hide=(true|false)/);
                return {
                  type: 'httpCodeBlock',
                  raw: match[0],
                  code: code,
                  name: nameMatch ? nameMatch[1].replace(/['"]/g, '') : '',
                  hide: hideMatch ? hideMatch[1] === 'true' : false
                };
              }
            },
            renderer(token) {
              return `<http-code-block code='${token.code.replace(/'/g, "&#39;")}' name="${token.name}" ${token.hide ? 'hide' : ''}></http-code-block>`;
            }
          }]
        });
      }

      updated(changedProperties) {
        if (changedProperties.has('markdown')) {
          this.processMarkdown();
        }
      }

      processMarkdown() {
        let htmlContent = marked.parse(this.markdown);

        // Replace ${data.xxx} placeholders
        htmlContent = htmlContent.replace(/\$\{data\.(\w+)\}/g, (match, queryName) => {
          const result = storeManager.getState(`data.${queryName}`);
          if (result) {
            return JSON.stringify(result).replace(/'/g, "&#39;");
          }
          return '[]';
        });

        this.processedHtml = htmlContent;
      }

      render() {
        return html`
          <div class="preview">
            ${this.processedHtml
            ? html`<div .innerHTML=${this.processedHtml}></div>`
            : html`<p style="color: #999;">Start typing markdown...</p>`}
          </div>
        `;
      }
    }

    class AppRoot extends LitElement {
      static properties = { markdownText: { type: String } };
      static styles = css`
        :host { display: block; height: 100%; }
        .container {
          display: grid;
          grid-template-columns: 1fr 1fr;
          height: 100%;
          gap: 1px;
          background: #ddd;
        }
        .panel {
          background: white;
          overflow: hidden;
          display: flex;
          flex-direction: column;
        }
        .panel-header {
          padding: 12px 20px;
          background: #f5f5f5;
          border-bottom: 1px solid #ddd;
          font-weight: 600;
        }
        .panel-content {
          flex: 1;
          overflow: hidden;
        }
      `;

      constructor() {
        super();
        this.markdownText = `# Welcome to Markdown Preview

## Features
- Live preview
- **Bold** and *italic* text
- Code snippets

\`\`\`javascript
const hello = "world";
console.log(hello);
\`\`\`

> This is a blockquote

### Lists
1. First item
2. Second item
3. Third item

### Data Table

<data-table
  data='[{"city":"Rio","pop":6748000},{"city":"SP","pop":12252000}]'
  columnConfig='[{"city":"City"},{"pop":"Population"}]'>
</data-table>

### Chart Example

<vegalite-chart
  spec='{"mark":"bar","encoding":{"x":{"field":"city","type":"nominal"},"y":{"field":"pop","type":"quantitative"}},"data":{"values":[{"city":"Rio","pop":6748000},{"city":"SP","pop":12252000},{"city":"BH","pop":2521564}]},"width":400,"height":200}'>
</vegalite-chart>

### SQL Query Example

\`\`\`sql name=sales_summary hide=false
SELECT
  'Product A' as product, 150000 as sales, 'Electronics' as category
UNION ALL
SELECT 'Product B', 120000, 'Electronics'
UNION ALL
SELECT 'Product C', 95000, 'Home'
UNION ALL
SELECT 'Product D', 200000, 'Electronics'
\`\`\`

### Using SQL Results in Components

<data-table
  data='\$\{data.sales_summary\}'
  columnConfig='[{"product":"Product"},{"sales":"Sales"},{"category":"Category"}]'>
</data-table>

<vegalite-chart
  spec='{"mark":"bar","encoding":{"x":{"field":"product","type":"nominal"},"y":{"field":"sales","type":"quantitative"}},"data":{"values":\$\{data.sales_summary\}},"width":400,"height":200}'>
</vegalite-chart>

### Interactive Filtering Example

\`\`\`sql name=product_list hide=true
SELECT DISTINCT product
FROM (
  SELECT 'Product A' as product
  UNION ALL SELECT 'Product B'
  UNION ALL SELECT 'Product C'
) t
ORDER BY product
\`\`\`

<dropdown-select
  data='\$\{data.product_list\}'
  name='product_selection'
  label='Select Products'>
</dropdown-select>

\`\`\`sql name=sales_data hide=true
WITH source_data AS (
  SELECT 'Product A' as product, 100 as sales, 'Q1' as quarter
  UNION ALL SELECT 'Product B', 150, 'Q1'
  UNION ALL SELECT 'Product C', 120, 'Q1'
  UNION ALL SELECT 'Product A', 130, 'Q2'
  UNION ALL SELECT 'Product B', 180, 'Q2'
  UNION ALL SELECT 'Product C', 140, 'Q2'
)
SELECT * FROM source_data
WHERE len(\$\{input.product_selection\}) = 0
   OR product IN (SELECT unnest(\$\{input.product_selection\}))
\`\`\`

<vegalite-chart
  spec='{"mark":"bar","encoding":{"x":{"field":"quarter","type":"nominal"},"y":{"field":"sales","type":"quantitative"},"color":{"field":"product","type":"nominal"}},"data":{"values":\$\{data.sales_data\}},"width":400,"height":200}'>
</vegalite-chart>

### GET HTTP Request Example

\`\`\`http name=todos hide=false
GET https://jsonplaceholder.typicode.com/todos/1 HTTP/1.1
\`\`\`

### POST Request Example

\`\`\`http name=create_post hide=false
POST https://jsonplaceholder.typicode.com/posts HTTP/1.1
Content-Type: application/json

{
  "title": "My Post",
  "body": "This is the post content",
  "userId": 1
}
\`\`\`
`;
      }

      connectedCallback() {
        super.connectedCallback();
        // listen for value-change events dispatched by inputs (like dropdown-select)
        this._valueChangeHandler = (e) => {
          const { name, value } = e.detail || {};
          if (name) {
            // Update global store here — decoupled from the component
            storeManager.setState(`input.${name}`, value);
          }
        };
        // Use event delegation on the component root so events from shadow DOM cross through
        this.addEventListener('value-change', this._valueChangeHandler);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._valueChangeHandler) {
          this.removeEventListener('value-change', this._valueChangeHandler);
        }
      }

      handleEditorChange(e) {
        this.markdownText = e.detail.value;
      }

      render() {
        return html`
          <div class="container">
            <div class="panel">
              <div class="panel-header">Markdown Editor</div>
              <div class="panel-content">
                <markdown-editor .value=${this.markdownText} @change=${this.handleEditorChange}></markdown-editor>
              </div>
            </div>
            <div class="panel">
              <div class="panel-header">Preview</div>
              <div class="panel-content">
                <markdown-preview .markdown=${this.markdownText}></markdown-preview>
              </div>
            </div>
          </div>
        `;
      }
    }

    customElements.define("dropdown-select", DropdownSelect);
    customElements.define("sql-code-block", SqlCodeBlock);
    customElements.define("http-code-block", HttpCodeBlock);
    customElements.define("vegalite-chart", VegaLiteChart);
    customElements.define("data-table", DataTable);
    customElements.define("markdown-editor", MarkdownEditor);
    customElements.define("markdown-preview", MarkdownPreview);
    customElements.define("app-root", AppRoot);

    document.getElementById("root").appendChild(document.createElement("app-root"));
  </script>
</body>

</html>